import eei::*;
import corectrl::*;

module memunit (
    clk   : input   clock               ,
    rst   : input   reset               ,
    valid : input   logic               ,
    is_new: input   logic               , // 命令が新しく供給されたかどうか
    ctrl  : input   InstCtrl            , // 命令のInstCtrl
    addr  : input   Addr                , // アクセスするアドレス
    rs2   : input   UIntX               , // ストア命令で書き込むデータ
    rdata : output  UIntX               , // ロード命令の結果 (stall = 0のときに有効)
    // #@@range_begin(port)
    stall : output  logic               , // メモリアクセス命令が完了していない
    membus: modport @<b>|core_data_if|::master, // メモリとのinterface
) {
    // #@@range_end(port)

    // memunitの状態を表す列挙型
    enum State: logic<2> {
        Init, // 命令を受け付ける状態
        WaitReady, // メモリが操作可能になるのを待つ状態
        WaitValid, // メモリ操作が終了するのを待つ状態
    }

    var state: State;

    // #@@range_begin(reg)
    var req_wen   : logic                       ;
    var req_addr  : Addr                        ;
    var req_wdata : logic<MEMBUS_DATA_WIDTH>    ;
    var req_wmask : logic<MEMBUS_DATA_WIDTH / 8>;
    @<b>|var req_is_amo: logic                       ;|
    @<b>|var req_amoop : AMOOp                       ;|
    @<b>|var req_aq    : logic                       ;|
    @<b>|var req_rl    : logic                       ;|
    @<b>|var req_funct3: logic<3>                    ;|
    // #@@range_end(reg)

    const W   : u32                      = XLEN;
    let D   : logic<MEMBUS_DATA_WIDTH> = membus.rdata;
    let sext: logic                    = ctrl.funct3[2] == 1'b0;

    // #@@range_begin(assign)
    always_comb {
        // メモリアクセス
        membus.valid  = state == State::WaitReady;
        membus.addr   = req_addr;
        membus.wen    = req_wen;
        membus.wdata  = req_wdata;
        membus.wmask  = req_wmask;
        @<b>|membus.is_amo = req_is_amo;|
        @<b>|membus.amoop  = req_amoop;|
        @<b>|membus.aq     = req_aq;|
        @<b>|membus.rl     = req_rl;|
        @<b>|membus.funct3 = req_funct3;|
    // #@@range_end(assign)
        // loadの結果
        rdata = case ctrl.funct3[1:0] {
            2'b00: case addr[2:0] {
                0      : {sext & D[7] repeat W - 8, D[7:0]},
                1      : {sext & D[15] repeat W - 8, D[15:8]},
                2      : {sext & D[23] repeat W - 8, D[23:16]},
                3      : {sext & D[31] repeat W - 8, D[31:24]},
                4      : {sext & D[39] repeat W - 8, D[39:32]},
                5      : {sext & D[47] repeat W - 8, D[47:40]},
                6      : {sext & D[55] repeat W - 8, D[55:48]},
                7      : {sext & D[63] repeat W - 8, D[63:56]},
                default: 'x,
            },
            2'b01: case addr[2:0] {
                0      : {sext & D[15] repeat W - 16, D[15:0]},
                2      : {sext & D[31] repeat W - 16, D[31:16]},
                4      : {sext & D[47] repeat W - 16, D[47:32]},
                6      : {sext & D[63] repeat W - 16, D[63:48]},
                default: 'x,
            },
            2'b10: case addr[2:0] {
                0      : {sext & D[31] repeat W - 32, D[31:0]},
                4      : {sext & D[63] repeat W - 32, D[63:32]},
                default: 'x,
            },
            2'b11  : D,
            default: 'x,
        };
        // stall判定
        stall = valid & case state {
            State::Init     : is_new && inst_is_memop(ctrl),
            State::WaitReady: 1,
            State::WaitValid: !membus.rvalid,
            default         : 0,
        };
    }

    // #@@range_begin(reset)
    always_ff {
        if_reset {
            state      = State::Init;
            req_wen    = 0;
            req_addr   = 0;
            req_wdata  = 0;
            req_wmask  = 0;
            @<b>|req_is_amo = 0;|
            @<b>|req_amoop  = 0 as AMOOp;|
            @<b>|req_aq     = 0;|
            @<b>|req_rl     = 0;|
            @<b>|req_funct3 = 0;|
        } else {
    //#@@range_end(reset)
            if valid {
                // #@@range_begin(Init)
                case state {
                    State::Init: if is_new & inst_is_memop(ctrl) {
                        ...
                        @<b>|req_is_amo = ctrl.is_amo;|
                        @<b>|req_amoop  = ctrl.funct7[6:2] as AMOOp;|
                        @<b>|req_aq     = ctrl.funct7[1];|
                        @<b>|req_rl     = ctrl.funct7[0];|
                        @<b>|req_funct3 = ctrl.funct3;|
                    }
                    State::WaitReady: if membus.ready {
                // #@@range_end(Init)
                        state = State::WaitValid;
                    }
                    State::WaitValid: if membus.rvalid {
                        state = State::Init;
                    }
                    default: {}
                }
            }
        }
    }
}
