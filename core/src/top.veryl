include (inline, "memory.sv");

module top (
    clk_in: input  logic   ,
    rst_in: input  logic   ,
    led   : output logic<6>,
    key   : input  logic<4>,
) {
    import eei::*;

    local LED_RESET  : logic<6> = 6'b000000;
    local LED_RUN    : logic<6> = 6'b111111;
    local LED_SUCCESS: logic<6> = 6'b111110;
    local LED_FAIL   : logic<6> = 6'b111101;

    enum LEDState: logic<2> {
        Reset,
        Run,
        Success,
        Fail,
    }

    var led_state: LEDState;

    // クロックを生成
    var clk: logic;
    var rst: logic;

    if (SYNTHESIS_GOWIN) :synth_if {
        inst gowin_pll: $sv::Gowin_PLL (
            clkout0: clk   ,
            clkin  : clk_in,
        );
        always_comb {
            rst = key[3] & led_state != 1;
        }
    } else {
        always_comb {
            clk = clk_in;
            rst = rst_in;
        }
    }

    // LED
    always_ff (clk, rst) {
        if_reset {
            led = LED_RESET;
        } else {
            led = case led_state {
                LEDState::Run    : LED_RUN,
                LEDState::Success: LED_SUCCESS,
                LEDState::Fail   : LED_FAIL,
                default          : LED_RESET,
            };
        }
    }

    // memory
    var mem_valid : logic    ;
    var mem_ready : logic    ;
    var mem_wen   : logic    ;
    var mem_addr  : Addr     ;
    var mem_wdata : UInt64   ;
    var mem_wmask : logic <8>;
    var mem_rvalid: logic    ;
    var mem_rdata : UInt64   ;

    local DataAddrWidth: u32 = 16;

    inst datamemory: $sv::memory #(
        DATA_WIDTH: 64           ,
        ADDR_WIDTH: DataAddrWidth,
    ) (
        clk                                      ,
        rst                                      ,
        ready : mem_ready                        ,
        valid : mem_valid                        ,
        wen   : mem_wen                          ,
        addr  : mem_addr[DataAddrWidth + 3 - 1:3],
        wdata : mem_wdata                        ,
        wmask : mem_wmask                        ,
        rvalid: mem_rvalid                       ,
        rdata : mem_rdata                        ,
    );

    inst ibus_if: membus_if;
    inst dbus_if: membus_if;

    var last_req_is_i: logic;

    always_comb {
        ibus_if.ready = mem_ready & !dbus_if.valid;
        dbus_if.ready = mem_ready;

        ibus_if.resp_valid = last_req_is_i & mem_rvalid;
        ibus_if.resp_rdata = mem_rdata;

        dbus_if.resp_valid = !last_req_is_i & mem_rvalid;
        dbus_if.resp_rdata = mem_rdata;

        mem_valid = ibus_if.valid | dbus_if.valid;
        if (dbus_if.valid) {
            mem_wen   = dbus_if.wen;
            mem_addr  = dbus_if.addr;
            mem_wdata = dbus_if.wdata;
            mem_wmask = dbus_if.wmask;
        } else {
            mem_wen   = 0;
            mem_addr  = ibus_if.addr;
            mem_wdata = ibus_if.wdata;
            mem_wmask = ibus_if.wmask;
        }
    }

    // memory arbiter
    always_ff (clk, rst) {
        if_reset {
            last_req_is_i = 0;
        } else {
            if (mem_ready) {
                last_req_is_i = !dbus_if.valid;
            }
        }
    }

    // riscv-tests
    always_ff (clk, rst) {
        if_reset {
            led_state = LEDState::Reset;
        } else {
            if (dbus_if.valid & dbus_if.wen & dbus_if.addr == eei::RISCVTESTS_EXIT_ADDR) {
                $display("wdata: %h", dbus_if.wdata);
                if (dbus_if.wdata == eei::RISCVTESTS_WDATA_SUCCESS) {
                    $display ("riscv-tests: Success!");
                    led_state = LEDState::Success;
                } else {
                    $error   ("riscv-tests: Fail");
                    led_state = LEDState::Fail;
                }
                $finish();
            } else {
                if (led_state != LEDState::Success && led_state != LEDState::Fail) {
                    led_state = LEDState::Run;
                }
            }
        }
    }

    inst c: core (
        clk      ,
        rst      ,
        ibus_if  ,
        dbus_if  ,
    );
}
