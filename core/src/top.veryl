import eei::*;

module top #(
    param MEMORY_FILEPATH_IS_ENV: bit    = 1                 ,
    param MEMORY_FILEPATH       : string = "MEMORY_FILE_PATH",
) (
    clk: input clock,
    rst: input reset,
    #[ifdef(TEST_MODE)]
    test_success: output bit,
) {

    // アドレスをメモリのデータ単位でのアドレスに変換する
    function addr_to_memaddr (
        addr: input logic<XLEN>          ,
    ) -> logic<MEM_ADDR_WIDTH> {
        return addr[$clog2(MEM_DATA_WIDTH / 8)+:MEM_ADDR_WIDTH];
    }

    inst membus  : membus_if::<MEM_DATA_WIDTH, MEM_ADDR_WIDTH>;
    inst i_membus: membus_if::<ILEN, XLEN>; // 命令フェッチ用
    inst d_membus: membus_if::<MEM_DATA_WIDTH, XLEN>; // ロードストア命令用

    // #@@range_begin(last_iaddr)
    var memarb_last_i    : logic;
    @<b>|var memarb_last_iaddr: Addr ;|
    // #@@range_end(last_iaddr)

    // riscv-testsの終了を検知する
    #[ifdef(TEST_MODE)]
    always_ff {
        let RISCVTESTS_TOHOST_ADDR: Addr = 'h1000 as Addr;
        if d_membus.valid && d_membus.ready && d_membus.wen == 1 && d_membus.addr == RISCVTESTS_TOHOST_ADDR && d_membus.wdata[lsb] == 1'b1 {
            test_success = d_membus.wdata == 1;
            if d_membus.wdata == 1 {
                $display("riscv-tests success!");
            } else {
                $display("riscv-tests failed!");
                $error  ("wdata : %h", d_membus.wdata);
            }
            $finish();
        }
    }

    // #@@range_begin(always_arb)
    // メモリアクセスを調停する
    always_ff {
        if_reset {
            memarb_last_i     = 0;
            @<b>|memarb_last_iaddr = 0;|
        } else {
            if membus.ready {
                memarb_last_i     = !d_membus.valid;
                @<b>|memarb_last_iaddr = i_membus.addr;|
            }
        }
    }
    // #@@range_end(always_arb)

    always_comb {
        i_membus.ready  = membus.ready && !d_membus.valid;
        i_membus.rvalid = membus.rvalid && memarb_last_i;
    // #@@range_begin(rdata)    
    i_membus.rdata  = if memarb_last_iaddr[2] == 0 {
        membus.rdata[31:0]
    } else {
        membus.rdata[63:32]
    };
    //#@@range_end(rdata)

        d_membus.ready  = membus.ready;
        d_membus.rvalid = membus.rvalid && !memarb_last_i;
        d_membus.rdata  = membus.rdata;

        membus.valid = i_membus.valid | d_membus.valid;
        if d_membus.valid {
            membus.addr  = addr_to_memaddr(d_membus.addr);
            membus.wen   = d_membus.wen;
            membus.wdata = d_membus.wdata;
            membus.wmask = d_membus.wmask;
        } else {
            membus.addr  = addr_to_memaddr(i_membus.addr);
            membus.wen   = 0; // 命令フェッチは常に読み込み
            membus.wdata = 'x;
            membus.wmask = 'x;
        }
    }

    inst mem: memory::<MEM_DATA_WIDTH, MEM_ADDR_WIDTH> #(
        FILEPATH_IS_ENV: MEMORY_FILEPATH_IS_ENV,
        FILEPATH       : MEMORY_FILEPATH       ,
    ) (
        clk     ,
        rst     ,
        membus  ,
    );

    inst c: core (
        clk       ,
        rst       ,
        i_membus  ,
        d_membus  ,
    );
}
