import eei::*;

module top #(
    param RAM_FILEPATH_IS_ENV: bit    = 1              ,
    param RAM_FILEPATH       : string = "RAM_FILE_PATH",
) (
    clk          : input clock,
    rst          : input reset,
    MMAP_DBG_ADDR: input Addr ,
    #[ifdef(TEST_MODE)]
    test_success: output bit  ,
    led         : output UIntX,
) {

    // アドレスをデータ単位でのアドレスに変換する
    function addr_to_memaddr::<DATA_WIDTH: u32, ADDR_WIDTH: u32> (
        addr: input logic<XLEN>,
    ) -> logic<ADDR_WIDTH> {
        return addr[$clog2(DATA_WIDTH / 8)+:ADDR_WIDTH];
    }

    // #@@range_begin(interface)
    @<b>|inst mmio_membus    : Membus;|
    @<b>|inst mmio_ram_membus: Membus;|
    inst @<b>|ram_|membus     : membus_if::<RAM_DATA_WIDTH, RAM_ADDR_WIDTH>;
    // #@@range_end(interface)

    inst i_membus: membus_if::<ILEN, XLEN>; // 命令フェッチ用
    inst d_membus: Membus; // ロードストア命令用

    var memarb_last_i    : logic;
    var memarb_last_iaddr: Addr ;

    // riscv-testsの終了を検知する
    // #@@range_begin(riscvtests)
    #[ifdef(TEST_MODE)]
    always_ff {
        let RISCVTESTS_TOHOST_ADDR: Addr = @<b>|MMAP_RAM_BEGIN +| 'h1000 as Addr;
        if d_membus.valid && d_membus.ready && d_membus.wen == 1 && d_membus.addr == RISCVTESTS_TOHOST_ADDR && d_membus.wdata[lsb] == 1'b1 {
            test_success = d_membus.wdata == 1;
            if d_membus.wdata == 1 {
                $display("riscv-tests success!");
            } else {
                $display("riscv-tests failed!");
                $error  ("wdata : %h", d_membus.wdata);
            }
            $finish();
        }
    }
    // #@@range_end(riscvtests)

    // #@@range_begin(arb)
    // @<b>|mmio_controller|へのメモリアクセスを調停する
    always_ff {
        if_reset {
            memarb_last_i     = 0;
            memarb_last_iaddr = 0;
        } else {
            if @<b>|mmio_|membus.ready {
                memarb_last_i     = !d_membus.valid;
                memarb_last_iaddr = i_membus.addr;
            }
        }
    }

    always_comb {
        i_membus.ready  = @<b>|mmio_|membus.ready && !d_membus.valid;
        i_membus.rvalid = @<b>|mmio_|membus.rvalid && memarb_last_i;
        i_membus.rdata  = if memarb_last_iaddr[2] == 0 ? @<b>|mmio_|membus.rdata[31:0] : mmio_|membus.rdata[63:32];

        d_membus.ready  = @<b>|mmio_|membus.ready;
        d_membus.rvalid = @<b>|mmio_|membus.rvalid && !memarb_last_i;
        d_membus.rdata  = @<b>|mmio_|membus.rdata;

        @<b>|mmio_|membus.valid = i_membus.valid | d_membus.valid;
        if d_membus.valid {
            @<b>|mmio_|membus.addr  = @<b>|d_membus.addr|;
            @<b>|mmio_|membus.wen   = d_membus.wen;
            @<b>|mmio_|membus.wdata = d_membus.wdata;
            @<b>|mmio_|membus.wmask = d_membus.wmask;
        } else {
            @<b>|mmio_|membus.addr  = @<b>|i_membus.addr|;
            @<b>|mmio_|membus.wen   = 0; // 命令フェッチは常に読み込み
            @<b>|mmio_|membus.wdata = 'x;
            @<b>|mmio_|membus.wmask = 'x;
        }
    }
    // #@@range_end(arb)

    // #@@range_begin(connect)
    always_comb {
        // mmio <> RAM
        ram_membus.valid       = mmio_ram_membus.valid;
        mmio_ram_membus.ready  = ram_membus.ready;
        ram_membus.addr        = addr_to_memaddr::<RAM_DATA_WIDTH, RAM_ADDR_WIDTH>(mmio_ram_membus.addr);
        ram_membus.wen         = mmio_ram_membus.wen;
        ram_membus.wdata       = mmio_ram_membus.wdata;
        ram_membus.wmask       = mmio_ram_membus.wmask;
        mmio_ram_membus.rvalid = ram_membus.rvalid;
        mmio_ram_membus.rdata  = ram_membus.rdata;
    }
    // #@@range_end(connect)

    // #@@range_begin(ram)
    inst ram: memory::<RAM_DATA_WIDTH, RAM_ADDR_WIDTH> #(
        FILEPATH_IS_ENV: RAM_FILEPATH_IS_ENV,
        FILEPATH       : RAM_FILEPATH       ,
    ) (
        clk               ,
        rst               ,
        @<b>|membus:| @<b>|ram_|membus,
    );
    // #@@range_end(ram)

    // #@@range_begin(inst)
    inst mmioc: mmio_controller (
        clk                        ,
        rst                        ,
        req_core  : mmio_membus    ,
        ram_membus: mmio_ram_membus,
    );
    // #@@range_end(inst)

    inst c: core (
        clk       ,
        rst       ,
        i_membus  ,
        d_membus  ,
        led       ,
    );
}
