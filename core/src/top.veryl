module top (
    clk_in: input  logic   ,
    rst_in: input  logic   ,
    led   : output logic<6>,
    key   : input  logic<4>,
) {

    import conf::*;

    var clk: logic;
    var rst: logic;

    if (SYNTHESIS_GOWIN) :synth_if {
        inst gowin_pll: $sv::Gowin_PLL (
            clkout0: clk   ,
            clkin  : clk_in,
        );
        always_comb {
            rst = key[3] & state != 1;
        }
    } else {
        always_comb {
            clk = clk_in;
            rst = rst_in;
        }
    }

    // memory
    var mem_valid : logic    ;
    var mem_ready : logic    ;
    var mem_wen   : logic    ;
    var mem_addr  : Addr     ;
    var mem_wdata : UInt64   ;
    var mem_wmask : logic <8>;
    var mem_rvalid: logic    ;
    var mem_rdata : UInt64   ;

    local DataAddrWidth: u32 = 16;

    inst datamemory: $sv::memory #(
        DATA_WIDTH: 64           ,
        ADDR_WIDTH: DataAddrWidth,
    ) (
        clk                                      ,
        rst                                      ,
        ready : mem_ready                        ,
        valid : mem_valid                        ,
        wen   : mem_wen                          ,
        addr  : mem_addr[DataAddrWidth + 3 - 1:3],
        wdata : mem_wdata                        ,
        wmask : mem_wmask                        ,
        rvalid: mem_rvalid                       ,
        rdata : mem_rdata                        ,
    );

    inst ireq : meminterface_req;
    inst iresp: meminterface_resp;
    inst dreq : meminterface_req;
    inst dresp: meminterface_resp;

    var last_req_is_i: logic;

    always_comb {
        ireq.ready = !dreq.valid;
        dreq.ready = 1;

        iresp.valid = last_req_is_i & mem_rvalid;
        iresp.rdata = mem_rdata;

        dresp.valid = !last_req_is_i & mem_rvalid;
        dresp.rdata = mem_rdata;

        mem_valid = ireq.valid | dreq.valid;
        if (dreq.valid) {
            mem_wen   = dreq.wen;
            mem_addr  = dreq.addr;
            mem_wdata = dreq.wdata;
            mem_wmask = dreq.wmask;
        } else {
            mem_wen   = 0;
            mem_addr  = ireq.addr;
            mem_wdata = ireq.wdata;
            mem_wmask = ireq.wmask;
        }
    }

    local RISCVTESTS_EXIT_ADDR    : Addr   = ('h1000) as Addr;
    local RISCVTESTS_WDATA_SUCCESS: UInt64 = 1;

    local LED_RESET  : logic<6> = 6'b000000;
    local LED_RUN    : logic<6> = 6'b111111;
    local LED_SUCCESS: logic<6> = 6'b111110;
    local LED_FAIL   : logic<6> = 6'b111101;

    // memory arbiter
    always_ff (clk, rst) {
        if_reset {
            last_req_is_i = 0;
        } else {
            if (mem_ready) {
                last_req_is_i = !dreq.valid;
            }
        }
    }

    var state: logic<2>;

    // LED
    always_ff (clk, rst) {
        if_reset {
            led = LED_RESET;
        } else {
            led = case state {
                0      : LED_RUN,
                1      : LED_SUCCESS,
                2      : LED_FAIL,
                default: LED_RESET,
            };
        }
    }

    // riscv-tests
    always_ff (clk, rst) {
        if_reset {
            state = 0;
        } else {
            if (dreq.valid & dreq.wen & dreq.addr == RISCVTESTS_EXIT_ADDR) {
                $display("wdata: %h", dreq.wdata);
                if (dreq.wdata == RISCVTESTS_WDATA_SUCCESS) {
                    $display("riscv-tests: Success!");
                    state    = 1;
                } else {
                    $error("riscv-tests: Fail");
                    state  = 2;
                }
                $finish();
            }
        }
    }

    inst c: core (
        clk    ,
        rst    ,
        ireq   ,
        iresp  ,
        dreq   ,
        dresp  ,
    );
}
