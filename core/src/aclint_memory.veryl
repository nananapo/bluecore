import eei::*;

module aclint_memory (
    clk   : input   clock            ,
    rst   : input   reset            ,
    membus: modport Membus::slave    ,
    aclint: modport aclint_if::master,
) {
    // #@@range_begin(reg)
    var msip0    : logic ;
    var mtime    : UInt64;
    var mtimecmp0: UInt64;
    // #@@range_end(reg)

    // #@@range_begin(comb)
    always_comb {
        aclint.msip = msip0;
        @<b>|aclint.mtip = mtime >= mtimecmp0;|
    }
    // #@@range_end(comb)

    assign membus.ready = 1;
    // #@@range_begin(reset)
    always_ff {
        if_reset {
            membus.rvalid = 0;
            membus.rdata  = 0;
            msip0         = 0;
            @<b>|mtime         = 0;|
            @<b>|mtimecmp0     = 0;|
    // #@@range_end(reset)
        } else {
            // count up mtime
            mtime += 1;

            membus.rvalid = membus.valid;
            if membus.valid {
                let addr: Addr = {membus.addr[XLEN - 1:3], 3'b0};
    // #@@range_begin(rw)
    if membus.wen {
        let M: logic<MEMBUS_DATA_WIDTH> = membus.wmask_expand();
        let D: logic<MEMBUS_DATA_WIDTH> = membus.wdata & M;
        case addr {
            MMAP_ACLINT_MSIP    : msip0     = D[0] | msip0 & ~M[0];
            @<b>{MMAP_ACLINT_MTIME   : mtime     = D | mtime & ~M;}
            @<b>{MMAP_ACLINT_MTIMECMP: mtimecmp0 = D | mtimecmp0 & ~M;}
            default             : {}
        }
    } else {
        membus.rdata = case addr {
            MMAP_ACLINT_MSIP    : {63'b0, msip0},
            @<b>|MMAP_ACLINT_MTIME   : mtime,|
            @<b>|MMAP_ACLINT_MTIMECMP: mtimecmp0,|
            default             : 0,
        };
    }
    // #@@range_end(rw)
            }
        }
    }
}
