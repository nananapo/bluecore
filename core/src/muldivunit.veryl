import eei::*;

module muldivunit (
    clk    : input  clock   ,
    rst    : input  reset   ,
    valid  : input  logic   ,
    funct3 : input  logic<3>,
    is_op32: input  logic   ,
    op1    : input  UIntX   ,
    op2    : input  UIntX   ,
    rvalid : output logic   ,
    result : output UIntX   ,
) {

    enum State {
        Idle,
        WaitValid,
        Finish,
    }

    var state: State;

    always_comb {
        rvalid = state == State::Finish;
    }

    // saved data
    var funct3_saved : logic<3>;
    var is_op32_saved: logic   ;

    let is_mul: logic = if state == State::Idle {
        !funct3[2]
    } else {
        !funct3_saved[2]
    };
    let req_valid: logic = state == State::Idle && valid;

    // multiply unit
    const MUL_WIDTH: u32 = XLEN + 1;

    var mu_rvalid: logic               ;
    var mu_result: logic<MUL_WIDTH * 2>;

    let mu_op1: logic<MUL_WIDTH> = if is_op32 {
        {op1[31] repeat MUL_WIDTH - 32, op1[31:0]} // MULW
    } else {
        case funct3[1:0] {
            2'b00, 2'b01, 2'b10: {op1[msb], op1}, // MUL, MULH, MULHSU
            2'b11              : {1'b0, op1}, // MULHU
            default            : 'x,
        }
    };

    let mu_op2: logic<MUL_WIDTH> = if is_op32 {
        {op2[31] repeat MUL_WIDTH - 32, op2[31:0]} // MULW
    } else {
        case funct3[1:0] {
            2'b00, 2'b01: {op2[msb], op2}, // MUL, MULH
            2'b10, 2'b11: {1'b0, op2}, // MULHSU, MULHU
            default     : 'x,
        }
    };

    inst mu: mulunit #(
        WIDTH: MUL_WIDTH,
    ) (
        clk                           ,
        rst                           ,
        valid    : req_valid && is_mul,
        op1_input: mu_op1             ,
        op2_input: mu_op2             ,
        rvalid   : mu_rvalid          ,
        result   : mu_result          ,
    );

    const DIV_WIDTH: u32 = XLEN + 1;

    var du_rvalid   : logic           ;
    var du_quotient : logic<DIV_WIDTH>;
    var du_remainder: logic<DIV_WIDTH>;

    let du_dividend: logic<DIV_WIDTH> = if is_op32 {
        {op1[31] & ~funct3[0] repeat DIV_WIDTH - 32, op1[31:0]}
    } else {
        case funct3[1:0] {
            2'b00, 2'b10: {op1[msb], op1},
            2'b01, 2'b11: {1'b0, op1},
            default     : 'x,
        }
    };

    let du_divisor: logic<DIV_WIDTH> = if is_op32 {
        {op2[31] & ~funct3[0] repeat DIV_WIDTH - 32, op2[31:0]}
    } else {
        case funct3[1:0] {
            2'b00, 2'b10: {op2[msb], op2},
            2'b01, 2'b11: {1'b0, op2},
            default     : 'x,
        }
    };

    inst du: divunit #(
        WIDTH: DIV_WIDTH,
    ) (
        clk                            ,
        rst                            ,
        valid    : req_valid && !is_mul,
        dividend : du_dividend         ,
        divisor  : du_divisor          ,
        rvalid   : du_rvalid           ,
        quotient : du_quotient         ,
        remainder: du_remainder        ,
    );

    always_ff {
        if_reset {
            state         = State::Idle;
            result        = 0;
            funct3_saved  = 0;
            is_op32_saved = 0;
        } else {
            case state {
                State::Idle: if valid {
                    state         = State::WaitValid;
                    funct3_saved  = funct3;
                    is_op32_saved = is_op32;
                }
                State::WaitValid: if is_mul && mu_rvalid {
                    state  = State::Finish;
                    result = if is_op32_saved {
                        {mu_result[31] repeat XLEN - 32, mu_result[31:0]}
                    } else {
                        case funct3_saved[1:0] {
                            2'b00              : mu_result[XLEN - 1:0], // MUL
                            2'b01, 2'b10, 2'b11: mu_result[XLEN * 2 - 1-:XLEN], // MULH, MULHSU, MULHU
                            default            : 0,
                        }
                    };
                } else if !is_mul && du_rvalid {
                    state  = State::Finish;
                    result = if is_op32_saved {
                        if funct3_saved[1] {
                            {du_remainder[31] repeat XLEN - 32, du_remainder[31:0]}
                        } else {
                            {du_quotient[31] repeat XLEN - 32, du_quotient[31:0]}
                        }
                    } else {
                        case funct3_saved[1:0] {
                            2'b00, 2'b01: du_quotient[XLEN - 1:0],
                            2'b10, 2'b11: du_remainder[XLEN - 1:0],
                            default     : 0,
                        }
                    };
                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}

module mulunit #(
    param WIDTH: u32 = 0,
) (
    clk      : input  clock           ,
    rst      : input  reset           ,
    valid    : input  logic           ,
    op1_input: input  logic<WIDTH>    ,
    op2_input: input  logic<WIDTH>    ,
    rvalid   : output logic           ,
    result   : output logic<WIDTH * 2>,
) {
    enum State {
        Idle,
        Init,
        AddLoop,
        Finish,
    }

    var state: State;

    var op1_sign: logic;
    var op2_sign: logic;

    var op1u: logic<WIDTH * 2>;
    var op2u: logic<WIDTH * 2>;

    always_comb {
        rvalid = state == State::Finish;
    }

    var add_count: logic<32>;

    always_ff {
        if_reset {
            state     = State::Idle;
            result    = 0;
            add_count = 0;
            op1_sign  = 0;
            op2_sign  = 0;
            op1u      = 0;
            op2u      = 0;
        } else {
            case state {
                State::Idle: if valid {
                    state     = State::Init;
                    result    = (1 << WIDTH) + ((op1_input[msb] * op2_input[msb]) << (WIDTH - 1) * 2);
                    add_count = 0;
                    op1_sign  = op1_input[msb];
                    op2_sign  = op2_input[msb];
                    op1u      = {1'b0 repeat WIDTH + 1, op1_input[msb - 1:0]};
                    op2u      = {1'b0 repeat WIDTH + 1, op2_input[msb - 1:0]};
                }
                State::Init: {
                                 let x     : logic<WIDTH * 2> = {op1_sign * op2u[WIDTH - 2] repeat 2, op1_sign * op2u[WIDTH - 2:0], 1'b1 repeat WIDTH - 1};
                                 let y     : logic<WIDTH * 2> = {op2_sign * op1u[WIDTH - 2] repeat 2, op2_sign * op1u[WIDTH - 2:0], 1'b1 repeat WIDTH - 1};
                                 result += ~x + ~y;
                                 state  =  State::AddLoop;
                             }
                State::AddLoop: {
                                    if op2u[add_count] {
                                        result += op1u;
                                    }
                                    if add_count == WIDTH - 2 {
                                        state = State::Finish;
                                    }
                                    op1u      <<= 1;
                                    add_count +=  1;
                                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}

module divunit #(
    param WIDTH: u32 = 0,
) (
    clk      : input  clock       ,
    rst      : input  reset       ,
    valid    : input  logic       ,
    dividend : input  logic<WIDTH>,
    divisor  : input  logic<WIDTH>,
    rvalid   : output logic       ,
    quotient : output logic<WIDTH>,
    remainder: output logic<WIDTH>,
) {
    enum State {
        Idle,
        Check,
        Loop,
        AdjustSign,
        Finish,
    }

    var state: State;

    var dividend_saved: logic<WIDTH * 2>;
    var divisor_saved : logic<WIDTH * 2>;

    var quotient_sign : logic    ;
    var remainder_sign: logic    ;
    var sub_count     : logic<32>;

    always_comb {
        rvalid    = state == State::Finish;
        remainder = dividend_saved[WIDTH - 1:0];
    }

    always_ff {
        if_reset {
            state          = State::Idle;
            dividend_saved = 0;
            divisor_saved  = 0;
            quotient_sign  = 0;
            remainder_sign = 0;
            sub_count      = 0;
            quotient       = 0;
        } else {
            case state {
                State::Idle: if valid {
                    quotient_sign  = dividend[msb] ^ divisor[msb];
                    remainder_sign = dividend[msb];
                    dividend_saved = {1'b0 repeat WIDTH, if dividend[msb] {
                        ~dividend + 1
                    } else {
                        dividend
                    }};
                    divisor_saved = {1'b0, if divisor[msb] {
                        ~divisor + 1
                    } else {
                        divisor
                    }, 1'b0 repeat WIDTH - 1};
                    quotient  = 0;
                    sub_count = 0;
                    state     = State::Check;
                }
                State::Check: {
                                  if divisor_saved == 0 {
                                      quotient = '1;
                                      if remainder_sign {
                                          dividend_saved = ~dividend_saved + 1;
                                      }
                                      state = State::Finish;
                                  } else {
                                      state = State::Loop;
                                  }
                              }
                State::Loop: {
                                 if dividend_saved >= divisor_saved {
                                     dividend_saved -= divisor_saved;
                                     quotient       =  (quotient << 1) + 1;
                                 } else {
                                     quotient <<= 1;
                                 }
                                 divisor_saved >>= 1;
                                 sub_count     +=  1;
                                 if sub_count == WIDTH - 1 {
                                     state = State::AdjustSign;
                                 }
                             }
                State::AdjustSign: {
                                       if quotient_sign {
                                           quotient = ~quotient + 1;
                                       }
                                       if remainder_sign {
                                           dividend_saved = ~dividend_saved + 1;
                                       }
                                       state = State::Finish;
                                   }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}
