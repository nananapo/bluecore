import eei::*;

module muldivunit (
    clk   : input  clock   ,
    rst   : input  reset   ,
    valid : input  logic   ,
    funct3: input  logic<3>,
    op1   : input  UIntX   ,
    op2   : input  UIntX   ,
    rvalid: output logic   ,
    result: output UIntX   ,
) {

    enum State {
        Idle,
        WaitValid,
        Finish,
    }

    var state: State;

    always_comb {
        rvalid = state == State::Finish;
    }

    // saved data
    var funct3_saved: logic<3>;

    let is_mul: logic = if state == State::Idle {
        !funct3[2]
    } else {
        !funct3_saved[2]
    };
    let req_valid: logic = state == State::Idle && valid;

    // multiply unit
    var mu_rvalid   : logic      ;
    var mu_result_hu: logic<XLEN>;

    inst mu: mulunit::<XLEN> (
        clk                           ,
        rst                           ,
        valid    : req_valid && is_mul,
        op1_input: op1                ,
        op2_input: op2                ,
        rvalid   : mu_rvalid          ,
        result_hu: mu_result_hu       ,
    );

    always_ff {
        if_reset {
            state        = State::Idle;
            result       = 0;
            funct3_saved = 0;
        } else {
            case state {
                State::Idle: if valid {
                    state        = State::WaitValid;
                    funct3_saved = funct3;
                }
                State::WaitValid: if is_mul && mu_rvalid {
                    state  = State::Finish;
                    result = case funct3_saved[1:0] {
                        2'b11  : mu_result_hu, // MULHU
                        default: 0,
                    };
                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}

module mulunit::<WIDTH: const> (
    clk      : input  clock       ,
    rst      : input  reset       ,
    valid    : input  logic       ,
    op1_input: input  logic<WIDTH>,
    op2_input: input  logic<WIDTH>,
    rvalid   : output logic       ,
    result_hu: output logic<WIDTH>,
) {
    enum State {
        Idle,
        AddLoop,
        Finish,
    }

    var state: State;

    var op1u: logic<WIDTH * 2>;
    var op2u: logic<WIDTH * 2>;

    always_comb {
        rvalid    = state == State::Finish;
        result_hu = result[msb-:WIDTH];
    }

    var result   : logic<WIDTH * 2>;
    var add_count: logic<32>       ;

    always_ff {
        if_reset {
            state     = State::Idle;
            result    = 0;
            add_count = 0;
            op1u      = 0;
            op2u      = 0;
        } else {
            case state {
                State::Idle: if valid {
                    state     = State::AddLoop;
                    result    = 0;
                    add_count = 0;
                    op1u      = {1'b0 repeat WIDTH, op1_input};
                    op2u      = {1'b0 repeat WIDTH, op2_input};
                }
                State::AddLoop: {
                                    if op2u[add_count] {
                                        result += op1u;
                                    }
                                    if add_count == WIDTH - 1 {
                                        state = State::Finish;
                                    }
                                    op1u      <<= 1;
                                    add_count +=  1;
                                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}
