import eei::*;

module muldivunit (
    clk    : input  clock   ,
    rst    : input  reset   ,
    ready  : output logic   ,
    valid  : input  logic   ,
    funct3 : input  logic<3>,
    is_op32: input  logic   ,
    op1    : input  UIntX   ,
    op2    : input  UIntX   ,
    rvalid : output logic   ,
    result : output UIntX   ,
) {

    enum State {
        Idle,
        WaitValid,
        Finish,
    }

    var state: State;

    // saved_data
    var funct3_saved : logic<3>;
    var is_op32_saved: logic   ;
    var op1sign_saved: logic   ;
    var op2sign_saved: logic   ;

    function abs::<WIDTH: u32> (
        value: input logic<WIDTH>,
    ) -> logic<WIDTH> {
        return if value[msb] ? ~value + 1 : value;
    }

    function sext::<WIDTH_IN: u32, WIDTH_OUT: u32> (
        value: input logic<WIDTH_IN>,
    ) -> logic<WIDTH_OUT> {
        return {value[msb] repeat WIDTH_OUT - WIDTH_IN, value};
    }

    // multiply unit
    const MUL_OP_WIDTH : u32 = XLEN;
    const MUL_RES_WIDTH: u32 = MUL_OP_WIDTH * 2;

    let is_mul   : logic                = if state == State::Idle ? !funct3[2] : !funct3_saved[2];
    var mu_rvalid: logic               ;
    var mu_result: logic<MUL_RES_WIDTH>;

    let mu_op1: logic<MUL_OP_WIDTH> = case funct3[1:0] {
        2'b00, 2'b01, 2'b10: abs::<XLEN>(if is_op32 ? sext::<32, XLEN>(op1[31:0]) : op1), // MUL, MULH, MULHSU, MULW
        2'b11              : op1, // MULHU
        default            : 0,
    };
    let mu_op2: logic<MUL_OP_WIDTH> = case funct3[1:0] {
        2'b00, 2'b01: abs::<XLEN>(if is_op32 ? sext::<32, XLEN>(op2[31:0]) : op2), // MUL, MULH, MULW
        2'b11, 2'b10: op2, // MULHU, MULHSU
        default     : 0,
    };

    inst mu: mulunit #(
        WIDTH: MUL_OP_WIDTH,
    ) (
        clk                             ,
        rst                             ,
        valid : ready && valid && is_mul,
        op1   : mu_op1                  ,
        op2   : mu_op2                  ,
        rvalid: mu_rvalid               ,
        result: mu_result               ,
    );

    always_comb {
        ready  = state == State::Idle;
        rvalid = state == State::Finish;
    }

    always_ff {
        if_reset {
            state         = State::Idle;
            result        = 0;
            funct3_saved  = 0;
            is_op32_saved = 0;
            op1sign_saved = 0;
            op2sign_saved = 0;
        } else {
            case state {
                State::Idle: if ready && valid {
                    state         = State::WaitValid;
                    funct3_saved  = funct3;
                    is_op32_saved = is_op32;
                    op1sign_saved = op1[msb];
                    op2sign_saved = op2[msb];
                }
                State::WaitValid: if is_mul && mu_rvalid {
                    let res_signed: logic<MUL_RES_WIDTH> = if op1sign_saved != op2sign_saved ? ~mu_result + 1 : mu_result;
                    let res_mulhsu: logic<MUL_RES_WIDTH> = if op1sign_saved == 1 ? ~mu_result + 1 : mu_result;
                    state      = State::Finish;
                    result     = case funct3_saved[1:0] {
                        2'b00  : if is_op32_saved ? sext::<32, 64>(res_signed[31:0]) : res_signed[XLEN - 1:0], // MUL, MULW
                        2'b01  : res_signed[XLEN+:XLEN], // MULH
                        2'b10  : res_mulhsu[XLEN+:XLEN], // MULHSU
                        2'b11  : mu_result[XLEN+:XLEN], // MULHU
                        default: 0,
                    };
                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}

module mulunit #(
    param WIDTH: u32 = 0,
) (
    clk   : input  clock           ,
    rst   : input  reset           ,
    valid : input  logic           ,
    op1   : input  logic<WIDTH>    ,
    op2   : input  logic<WIDTH>    ,
    rvalid: output logic           ,
    result: output logic<WIDTH * 2>,
) {
    enum State {
        Idle,
        AddLoop,
        Finish,
    }

    var state: State;

    var op1zext: logic<WIDTH * 2>;
    var op2zext: logic<WIDTH * 2>;

    always_comb {
        rvalid = state == State::Finish;
    }

    var add_count: u32;

    always_ff {
        if_reset {
            state     = State::Idle;
            result    = 0;
            add_count = 0;
            op1zext   = 0;
            op2zext   = 0;
        } else {
            case state {
                State::Idle: if valid {
                    state     = State::AddLoop;
                    result    = 0;
                    add_count = 0;
                    op1zext   = {1'b0 repeat WIDTH, op1};
                    op2zext   = {1'b0 repeat WIDTH, op2};
                }
                State::AddLoop: if add_count == WIDTH {
                    state = State::Finish;
                } else {
                    if op2zext[add_count] {
                        result += op1zext;
                    }
                    op1zext   <<= 1;
                    add_count +=  1;
                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}
