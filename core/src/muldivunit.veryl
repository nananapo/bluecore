import eei::*;

module muldivunit (
    clk   : input  clock   ,
    rst   : input  reset   ,
    ready : output logic   ,
    valid : input  logic   ,
    funct3: input  logic<3>,
    op1   : input  UIntX   ,
    op2   : input  UIntX   ,
    rvalid: output logic   ,
    result: output UIntX   ,
) {

    enum State {
        Idle,
        WaitValid,
        Finish,
    }

    var state: State;

    // #@@range_begin(opsign_save_reg)
    // saved_data
    var funct3_saved : logic<3>;
    @<b>|var op1sign_saved: logic   ;|
    @<b>|var op2sign_saved: logic   ;|
    // #@@range_end(opsign_save_reg)

    // #@@range_begin(abs)
    function abs::<WIDTH: u32> (
        value: input logic<WIDTH>,
    ) -> logic<WIDTH> {
        return if value[msb] ? ~value + 1 : value;
    }
    // #@@range_end(abs)

    // multiply unit
    const MUL_OP_WIDTH : u32 = XLEN;
    const MUL_RES_WIDTH: u32 = MUL_OP_WIDTH * 2;

    let is_mul   : logic                = if state == State::Idle ? !funct3[2] : !funct3_saved[2];
    var mu_rvalid: logic               ;
    var mu_result: logic<MUL_RES_WIDTH>;

    // #@@range_begin(op1op2)
    let mu_op1: logic<MUL_OP_WIDTH> = case funct3[1:0] {
        2'b00, 2'b01: abs::<XLEN>(op1), // MUL, MULH
        2'b11       : op1, // MULHU
        default     : 0,
    };
    let mu_op2: logic<MUL_OP_WIDTH> = case funct3[1:0] {
        2'b00, 2'b01: abs::<XLEN>(op2), // MUL, MULH
        2'b11       : op2, // MULHU
        default     : 0,
    };
    // #@@range_end(op1op2)

    // #@@range_begin(mu)
    inst mu: mulunit #(
        WIDTH: MUL_OP_WIDTH,
    ) (
        clk                             ,
        rst                             ,
        valid : ready && valid && is_mul,
        op1   : @<b>|mu_op1|                  ,
        op2   : @<b>|mu_op2|                  ,
        rvalid: mu_rvalid               ,
        result: mu_result               ,
    );
    // #@@range_end(mu)

    always_comb {
        ready  = state == State::Idle;
        rvalid = state == State::Finish;
    }

    // #@@range_begin(always_reset)
    always_ff {
        if_reset {
            state         = State::Idle;
            result        = 0;
            funct3_saved  = 0;
            @<b>|op1sign_saved = 0;|
            @<b>|op2sign_saved = 0;|
        } else {
    // #@@range_end(always_reset)
    // #@@range_begin(idle)
    case state {
        State::Idle: if ready && valid {
            state         = State::WaitValid;
            funct3_saved  = funct3;
            @<b>|op1sign_saved = op1[msb];|
            @<b>|op2sign_saved = op2[msb];|
        }
    // #@@range_end(idle)
    // #@@range_begin(wait_valid)
    State::WaitValid: if is_mul && mu_rvalid {
        @<b>|let res_signed: logic<MUL_RES_WIDTH> = if op1sign_saved != op2sign_saved ? ~mu_result + 1 : mu_result;|
        state      = State::Finish;
        result     = case funct3_saved[1:0] {
            @<b>|2'b00  : res_signed[XLEN - 1:0], // MUL|
            @<b>|2'b01  : res_signed[XLEN+:XLEN], // MULH|
            2'b11  : mu_result[XLEN+:XLEN], // MULHU
            default: 0,
        };
    }
    // #@@range_end(wait_valid)
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}

module mulunit #(
    param WIDTH: u32 = 0,
) (
    clk   : input  clock           ,
    rst   : input  reset           ,
    valid : input  logic           ,
    op1   : input  logic<WIDTH>    ,
    op2   : input  logic<WIDTH>    ,
    rvalid: output logic           ,
    result: output logic<WIDTH * 2>,
) {
    enum State {
        Idle,
        AddLoop,
        Finish,
    }

    var state: State;

    var op1zext: logic<WIDTH * 2>;
    var op2zext: logic<WIDTH * 2>;

    always_comb {
        rvalid = state == State::Finish;
    }

    var add_count: u32;

    always_ff {
        if_reset {
            state     = State::Idle;
            result    = 0;
            add_count = 0;
            op1zext   = 0;
            op2zext   = 0;
        } else {
            case state {
                State::Idle: if valid {
                    state     = State::AddLoop;
                    result    = 0;
                    add_count = 0;
                    op1zext   = {1'b0 repeat WIDTH, op1};
                    op2zext   = {1'b0 repeat WIDTH, op2};
                }
                State::AddLoop: if add_count == WIDTH {
                    state = State::Finish;
                } else {
                    if op2zext[add_count] {
                        result += op1zext;
                    }
                    op1zext   <<= 1;
                    add_count +=  1;
                }
                State::Finish: state = State::Idle;
                default      : {}
            }
        }
    }
}
