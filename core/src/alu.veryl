import eei::*;
import corectrl::*;

module alu (
    cmd      : input  AluCmd,
    is_signed: input  logic ,
    op1_data : input  UIntX ,
    op2_data : input  UIntX ,
    result   : output UIntX ,
) {

    let op1_s: SIntX = op1_data;
    let op2_s: SIntX = op2_data;

    always_comb {
        case (cmd) {
            AluCmd::ADD: result = op1_data + op2_data;
            AluCmd::SUB: result = op1_data - op2_data;
            AluCmd::AND: result = op1_data & op2_data;
            AluCmd::OR : result = op1_data | op2_data;
            AluCmd::XOR: result = op1_data ^ op2_data;
            AluCmd::SLL: result = op1_data << op2_data[4:0];
            AluCmd::SRL: result = op1_data >> op2_data[4:0];
            AluCmd::SRA: result = $signed(op1_s >>> op2_s[4:0]);
            AluCmd::SLT: result = if (is_signed) {
                             {1'b0 repeat XLEN - 1, (op1_s <: op2_s)} // SLT
                                      } else {
                             {1'b0 repeat XLEN - 1, op1_data <: op2_data} // SLTU
                                      };
            AluCmd::JALR : result = (op1_data + op2_data) & (~1);
            AluCmd::COPY1: result = op1_data;
            default      : result = XLEN_X;
        }
    }
}
