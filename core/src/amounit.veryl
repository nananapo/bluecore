import eei::*;

module amounit (
    clk   : input   clock              ,
    rst   : input   reset              ,
    slave : modport core_data_if::slave,
    master: modport Membus::master     ,
) {

    // #@@range_begin(State)
    enum State {
        Init,
        WaitReady,
        WaitValid,
        @<b>|SCSuccess,|
        @<b>|SCFail,|
    }
    // #@@range_end(State)

    var state      : State;
    inst slave_saved: core_data_if;

    // masterをリセットする
    function reset_master () {
        master.valid = 0;
        master.addr  = 0;
        master.wen   = 0;
        master.wdata = 0;
        master.wmask = 0;
    }

    // lr/sc
    var is_addr_reserved: logic;
    var reserved_addr   : Addr ;

    // masterに要求を割り当てる
    function assign_master (
        addr : input Addr                   ,
        wen  : input logic                  ,
        wdata: input UIntX                  ,
        wmask: input logic<$size(UIntX) / 8>,
    ) {
        master.valid = 1;
        master.addr  = addr;
        master.wen   = wen;
        master.wdata = wdata;
        master.wmask = wmask;
    }

    // 新しく要求を受け入れる
    function accept_request_comb () {
        if slave.ready && slave.valid {
            if slave.is_amo {
    // #@@range_begin(accept_request_comb)
    case slave.amoop {
        AMOOp::LR: assign_master(slave.addr, 0, 0, 0);
        @<b>|AMOOp::SC: if is_addr_reserved && slave.addr == reserved_addr {|
        @<b>     assign_master(slave.addr, 1, slave.wdata, slave.wmask);|
        @<b> }|
        default: {}
    }
    // #@@range_end(accept_request_comb)
            } else {
                assign_master(slave.addr, slave.wen, slave.wdata, slave.wmask);
            }
        }
    }

    // slaveに結果を割り当てる
    always_comb {
        slave.ready  = 0;
        slave.rvalid = 0;
        slave.rdata  = 0;

        case state {
            State::Init: {
                slave.ready = 1;
            }
            State::WaitValid: {
                slave.ready  = master.rvalid;
                slave.rvalid = master.rvalid;
                slave.rdata  = master.rdata;
            }
    // #@@range_begin(assign_slave)
    State::SCSuccess: {
        slave.ready  = master.rvalid;
        slave.rvalid = master.rvalid;
        slave.rdata  = 0;
    }
    State::SCFail: {
        slave.ready  = 1;
        slave.rvalid = 1;
        slave.rdata  = 1;
    }
    // #@@range_end(assign_slave)
            default: {}
        }
    }

    // masterに要求を割り当てる
    // #@@range_begin(master_comb)
    always_comb {
        reset_master();
        case state {
            State::Init     : accept_request_comb();
            State::WaitReady: if slave_saved.is_amo {
                case slave_saved.amoop {
                    AMOOp::LR: assign_master(slave_saved.addr, 0, 0, 0);
                    @<b>|AMOOp::SC: assign_master(slave_saved.addr, 1, slave_saved.wdata, slave_saved.wmask);|
                    default  : {}
                }
            } else {
                assign_master(slave_saved.addr, slave_saved.wen, slave_saved.wdata, slave_saved.wmask);
            }
            State::WaitValid               : accept_request_comb();
            @<b>|State::SCFail, State::SCSuccess: accept_request_comb();|
            default                        : {}
        }
    }
    // #@@range_end(master_comb)

    // 新しく要求を受け入れる
    function accept_request_ff () {
        slave_saved.valid = slave.ready && slave.valid;
        if slave.ready && slave.valid {
            slave_saved.addr   = slave.addr;
            slave_saved.wen    = slave.wen;
            slave_saved.wdata  = slave.wdata;
            slave_saved.wmask  = slave.wmask;
            slave_saved.is_amo = slave.is_amo;
            slave_saved.amoop  = slave.amoop;
            slave_saved.aq     = slave.aq;
            slave_saved.rl     = slave.rl;
            slave_saved.funct3 = slave.funct3;
            if slave.is_amo {
                case slave.amoop {
                    AMOOp::LR: {
                        // reserve address
                        is_addr_reserved = 1;
                        reserved_addr    = slave.addr;
                        state            = if master.ready ? State::WaitValid : State::WaitReady;
                    }
    // #@@range_begin(accept_request_ff)
    AMOOp::SC: {
        // reset reserved
        let prev            : logic = is_addr_reserved;
        is_addr_reserved = 0;
        // check
        if prev && slave.addr == reserved_addr {
            state = if master.ready ? State::SCSuccess : State::WaitReady;
        } else {
            state = State::SCFail;
        }
    }
    // #@@range_end(accept_request_ff)
                    default: {}
                }
            } else {
                state = if master.ready ? State::WaitValid : State::WaitReady;
            }
        } else {
            state = State::Init;
        }
    }

    // #@@range_begin(on_clock)
    function on_clock () {
        case state {
            State::Init     : accept_request_ff();
            State::WaitReady: if master.ready {
                @<b>|if slave_saved.is_amo && slave_saved.amoop == AMOOp::SC {|
                @<b>|    state = State::SCSuccess;|
                @<b>|} else {|
                    state = State::WaitValid;
                @<b>|}|
            }
            State::WaitValid: if master.rvalid {
                accept_request_ff();
            }
            @<b>|State::SCSuccess: if master.rvalid {|
            @<b>|    accept_request_ff();|
            @<b>|}|
            @<b>|State::SCFail: accept_request_ff();|
            default      : {}
        }
    }
    // #@@range_end(on_clock)

    function on_reset () {
        state              = State::Init;
        slave_saved.addr   = 0;
        slave_saved.wen    = 0;
        slave_saved.wdata  = 0;
        slave_saved.wmask  = 0;
        slave_saved.is_amo = 0;
        slave_saved.amoop  = 0 as AMOOp;
        slave_saved.aq     = 0;
        slave_saved.rl     = 0;
        slave_saved.funct3 = 0;
        is_addr_reserved   = 0;
        reserved_addr      = 0;
    }

    always_ff {
        if_reset {
            on_reset();
        } else {
            on_clock();
        }
    }
}
