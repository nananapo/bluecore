module core (
    clk  : input   logic                   ,
    rst  : input   logic                   ,
    ireq : modport meminterface_req::slave ,
    iresp: modport meminterface_resp::slave,
    dreq : modport meminterface_req::slave ,
    dresp: modport meminterface_resp::slave,

) {

    import conf::*;
    import stage::*;

    // clock count
    var clock_count: u64;

    // stage var
    struct if_idq_type {
        addr   : Addr,
        instbit: Inst,
    }
    var if_idq_wready_do_not_use: logic      ;
    var if_idq_wready_next      : logic      ;
    var if_idq_wvalid           : logic      ;
    var if_idq_wdata            : if_idq_type;
    var if_idq_rready           : logic      ;
    var if_idq_rvalid           : logic      ;
    var if_idq_rdata            : if_idq_type;

    struct stageinfo {
        addr   : Addr    ,
        instbit: Inst    ,
        ctrl   : InstCtrl,
    }

    struct id_dsq_type {
        info: stageinfo,
    }
    var id_dsq_wready: logic      ;
    var id_dsq_wvalid: logic      ;
    var id_dsq_wdata : id_dsq_type;
    var id_dsq_rready: logic      ;
    var id_dsq_rvalid: logic      ;
    var id_dsq_rdata : id_dsq_type;

    struct register_context {
        rs1_addr: logic<5>,
        rs2_addr: logic<5>,
        rd_addr : logic<5>,
    }

    struct forwarding_context {
        valid: logic,
        data : UIntX,
    }

    struct ds_exeq_type {
        info  : stageinfo         ,
        op1   : UIntX             ,
        op2   : UIntX             ,
        rs2   : UIntX             ,
        regctx: register_context  ,
        fwctx : forwarding_context,
    }
    var ds_exeq_wready: logic       ;
    var ds_exeq_wvalid: logic       ;
    var ds_exeq_wdata : ds_exeq_type;
    var ds_exeq_rready: logic       ;
    var ds_exeq_rvalid: logic       ;
    var ds_exeq_rdata : ds_exeq_type;

    struct exe_memq_type {
        info     : stageinfo         ,
        rs2      : UIntX             ,
        regctx   : register_context  ,
        alu_out  : UIntX             ,
        br_taken : logic             ,
        br_target: Addr              ,
        nextpc   : Addr              ,
        fwctx    : forwarding_context,
    }
    var exe_memq_wready: logic        ;
    var exe_memq_wvalid: logic        ;
    var exe_memq_wdata : exe_memq_type;
    var exe_memq_rready: logic        ;
    var exe_memq_rvalid: logic        ;
    var exe_memq_rdata : exe_memq_type;

    struct mem_wbq_type {
        info   : stageinfo         ,
        regctx : register_context  ,
        alu_out: UIntX             ,
        mem_out: UIntX             ,
        csr_out: UIntX             ,
        fwctx  : forwarding_context,
    }
    var mem_wbq_wready: logic       ;
    var mem_wbq_wvalid: logic       ;
    var mem_wbq_wdata : mem_wbq_type;
    var mem_wbq_rready: logic       ;
    var mem_wbq_rvalid: logic       ;
    var mem_wbq_rdata : mem_wbq_type;

    var mem_next_pc_expected: Addr ;
    var mem_is_branch_hazard: logic;

    let reset_before_memstage: logic = mem_is_branch_hazard | mem_csr_is_trap;

    // program counter
    var if_pc          : Addr ;
    var if_is_requested: logic;
    var if_requested_pc: Addr ;

    // fetch
    always_comb {
        ireq.valid = if_idq_wready_next & (!if_is_requested | iresp.valid);
        ireq.addr  = if_pc;
        ireq.wen   = 0;
        ireq.wdata = 'x;
        ireq.wmask = 0;
    }

    // fetched inst
    let if_fetch_inst: Inst = if (if_requested_pc[2] == 0) {
        iresp.rdata[31:0]
    } else {
        iresp.rdata[63:32]
    };

    // if -> id queue
    always_comb {
        if_idq_wvalid        = if_is_requested & iresp.valid;
        if_idq_wdata.addr    = if_requested_pc;
        if_idq_wdata.instbit = if_fetch_inst;
        if_idq_rready        = id_dsq_wready;
    }

    // decode stage
    var id_info: stageinfo;
    always_comb {
        id_info.addr    = if_idq_rdata.addr;
        id_info.instbit = if_idq_rdata.instbit;
        // ctrl is assigned in decoder instance
    }

    // id -> ds queue
    always_comb {
        id_dsq_wvalid     = if_idq_rvalid;
        id_dsq_wdata.info = id_info;
        id_dsq_rready     = !id_dsq_wvalid | ds_exeq_wready & ds_exeq_wvalid;
    }

    // register
    var regfile: UIntX<32>;

    // ds stage
    let ds_info: stageinfo = id_dsq_rdata.info;
    var ds_op1 : UIntX    ;
    var ds_op2 : UIntX    ;
    var ds_rs1 : UIntX    ;
    var ds_rs2 : UIntX    ;

    // const value
    let ds_rs1_addr: logic<5> = ds_info.instbit[19:15];
    let ds_rs2_addr: logic<5> = ds_info.instbit[24:20];
    let ds_rd_addr : logic<5> = ds_info.instbit[11:7];
    var ds_imm_i   : UIntX   ;
    var ds_imm_s   : UIntX   ;
    var ds_imm_j   : UIntX   ;
    var ds_imm_u   : UIntX   ;
    var ds_imm_z   : UIntX   ;

    let ds_dh_ds_rs1: logic = ds_rs1_addr != 0;
    let ds_dh_ds_rs2: logic = ds_rs2_addr != 0;

    let ds_dh_exe_rs1: logic = ds_dh_ds_rs1 & ds_exeq_rvalid & exe_info.ctrl.rf_wen & exe_regctx.rd_addr == ds_rs1_addr;
    let ds_dh_mem_rs1: logic = ds_dh_ds_rs1 & exe_memq_rvalid & mem_info.ctrl.rf_wen & mem_regctx.rd_addr == ds_rs1_addr;
    let ds_dh_wb_rs1 : logic = ds_dh_ds_rs1 & mem_wbq_rvalid & wb_info.ctrl.rf_wen & wb_regctx.rd_addr == ds_rs1_addr;

    let ds_dh_exe_rs2: logic = ds_dh_ds_rs2 & ds_exeq_rvalid & exe_info.ctrl.rf_wen & exe_regctx.rd_addr == ds_rs2_addr;
    let ds_dh_mem_rs2: logic = ds_dh_ds_rs2 & exe_memq_rvalid & mem_info.ctrl.rf_wen & mem_regctx.rd_addr == ds_rs2_addr;
    let ds_dh_wb_rs2 : logic = ds_dh_ds_rs2 & mem_wbq_rvalid & wb_info.ctrl.rf_wen & wb_regctx.rd_addr == ds_rs2_addr;

    let ds_dh_rs1: logic = ds_info.ctrl.op1_sel == Op1Sel::RS1 & ds_dh_ds_rs1 & (if (ds_dh_exe_rs1) {
        !exe_fwctx.valid
    } else if (ds_dh_mem_rs1) {
        !mem_fwctx.valid
    } else if (ds_dh_wb_rs1) {
        !wb_fwctx.valid
    } else {
        0
    });
    let ds_dh_rs2: logic = ds_info.ctrl.use_rs2 & ds_dh_ds_rs2 & (if (ds_dh_exe_rs2) {
        !exe_fwctx.valid
    } else if (ds_dh_mem_rs2) {
        !mem_fwctx.valid
    } else if (ds_dh_wb_rs2) {
        !wb_fwctx.valid
    } else {
        0
    });

    let ds_stall: logic = ds_dh_rs1 | ds_dh_rs2; // datahazard

    always_comb {
        ds_rs1 = if ds_dh_exe_rs1 {
            exe_fwctx.data
        } else if ds_dh_mem_rs1 {
            mem_fwctx.data
        } else if ds_dh_wb_rs1 {
            wb_fwctx.data
        } else {
            regfile[ds_rs1_addr]
        };
        ds_rs2 = if ds_dh_exe_rs2 {
            exe_fwctx.data
        } else if ds_dh_mem_rs2 {
            mem_fwctx.data
        } else if ds_dh_wb_rs2 {
            wb_fwctx.data
        } else {
            regfile[ds_rs2_addr]
        };
        case ds_info.ctrl.op1_sel {
            Op1Sel::RS1: ds_op1 = ds_rs1;
            Op1Sel::PC : ds_op1 = ds_info.addr;
            Op1Sel::IMZ: ds_op1 = ds_imm_z;
            default    : ds_op1 = XLEN_X;
        }
        case (ds_info.ctrl.op2_sel) {
            Op2Sel::RS2: ds_op2 = ds_rs2;
            Op2Sel::IMI: ds_op2 = ds_imm_i;
            Op2Sel::IMS: ds_op2 = ds_imm_s;
            Op2Sel::IMJ: ds_op2 = ds_imm_j;
            Op2Sel::IMU: ds_op2 = ds_imm_u;
            Op2Sel::IMZ: ds_op2 = ds_imm_z;
            default    : ds_op2 = XLEN_X;
        }
    }

    // ds -> exe queue
    always_comb {
        ds_exeq_wvalid                = id_dsq_rvalid & !ds_stall;
        ds_exeq_wdata.info            = ds_info;
        ds_exeq_wdata.op1             = ds_op1;
        ds_exeq_wdata.op2             = ds_op2;
        ds_exeq_wdata.rs2             = ds_rs2;
        ds_exeq_wdata.regctx.rs1_addr = if (ds_info.ctrl.op1_sel == Op1Sel::RS1) {
            ds_rs1_addr
        } else {
            0
        };
        ds_exeq_wdata.regctx.rs2_addr = if (ds_info.ctrl.use_rs2) {
            ds_rs2_addr
        } else {
            0
        };
        ds_exeq_wdata.regctx.rd_addr = if (ds_info.ctrl.rf_wen) {
            ds_rd_addr
        } else {
            0
        };
        ds_exeq_wdata.fwctx.valid = ds_info.ctrl.wb_sel == WbSel::PC;
        ds_exeq_wdata.fwctx.data  = ds_info.addr + 4;
        ds_exeq_rready            = !ds_exeq_rvalid | exe_memq_wready & exe_memq_wvalid;
    }

    // exe stage
    let exe_info    : stageinfo          = ds_exeq_rdata.info;
    var exe_alu_out : UIntX             ;
    var exe_br_taken: logic             ;
    let exe_op1     : UIntX              = ds_exeq_rdata.op1;
    let exe_op2     : UIntX              = ds_exeq_rdata.op2;
    let exe_rs2     : UIntX              = ds_exeq_rdata.rs2;
    let exe_regctx  : register_context   = ds_exeq_rdata.regctx;
    let exe_fwctx   : forwarding_context = ds_exeq_rdata.fwctx;
    var exe_imm_b   : UIntX             ;

    let exe_stall: logic = !id_dsq_rvalid; // wait ds is valid

    // exe -> mem queue
    always_comb {
        exe_memq_wvalid          = ds_exeq_rvalid & !exe_stall;
        exe_memq_wdata.info      = exe_info;
        exe_memq_wdata.rs2       = exe_rs2;
        exe_memq_wdata.regctx    = exe_regctx;
        exe_memq_wdata.alu_out   = exe_alu_out;
        exe_memq_wdata.br_taken  = exe_br_taken | exe_info.ctrl.br_cmd == BrCmd::JLI | exe_info.ctrl.br_cmd == BrCmd::JLR;
        exe_memq_wdata.br_target = case (exe_info.ctrl.br_cmd) {
            BrCmd::JLI: exe_alu_out,
            BrCmd::JLR: exe_alu_out,
            default   : exe_info.addr + exe_imm_b // branch
            ,
        } & (~1);
        exe_memq_wdata.nextpc      = ds_info.addr;
        exe_memq_wdata.fwctx.valid = exe_fwctx.valid | exe_info.ctrl.wb_sel == WbSel::ALU;
        exe_memq_wdata.fwctx.data  = if (exe_fwctx.valid) {
            exe_fwctx.data
        } else {
            exe_alu_out
        };
    }

    // mem stage
    let mem_valid         : logic              = exe_memq_rvalid;
    var mem_is_new        : logic             ;
    var mem_memunit_stall : logic             ;
    let mem_info          : stageinfo          = exe_memq_rdata.info;
    let mem_regctx        : register_context   = exe_memq_rdata.regctx;
    let mem_fwctx         : forwarding_context = exe_memq_rdata.fwctx;
    let mem_alu_out       : UIntX              = exe_memq_rdata.alu_out;
    let mem_br_taken      : logic              = exe_memq_rdata.br_taken;
    let mem_br_target     : Addr               = exe_memq_rdata.br_target;
    let mem_rs2           : UIntX              = exe_memq_rdata.rs2;
    var mem_mem_rdata     : UIntX             ;
    let mem_next_pc_actual: Addr               = exe_memq_rdata.nextpc;

    var mem_csr_rdata      : UIntX;
    var mem_csrunit_stall  : logic;
    var mem_csr_is_trap    : logic;
    var mem_csr_trap_vector: Addr ;

    assign mem_next_pc_expected = if (mem_info.ctrl.br_cmd == BrCmd::X | !mem_br_taken) {
        mem_info.addr + 4
    } else {
        mem_br_target
    };

    // TODO assert
    assign mem_is_branch_hazard = mem_valid & mem_next_pc_expected != mem_next_pc_actual;

    always_comb {
        exe_memq_rready           = !mem_memunit_stall & !mem_csrunit_stall & mem_wbq_wready;
        mem_wbq_wvalid            = mem_valid & !mem_memunit_stall & !mem_csrunit_stall;
        mem_wbq_wdata.info        = mem_info;
        mem_wbq_wdata.regctx      = mem_regctx;
        mem_wbq_wdata.alu_out     = mem_alu_out;
        mem_wbq_wdata.mem_out     = mem_mem_rdata;
        mem_wbq_wdata.csr_out     = mem_csr_rdata;
        mem_wbq_wdata.fwctx.valid = 1;
        mem_wbq_wdata.fwctx.data  = if (mem_fwctx.valid) {
            mem_fwctx.data
        } else if (mem_info.ctrl.wb_sel == WbSel::MEM) {
            mem_mem_rdata
        } else {
            mem_csr_rdata
        };
    }

    // wb stage
    let wb_valid : logic            = mem_wbq_rvalid;
    let wb_info  : stageinfo        = mem_wbq_rdata.info;
    let wb_regctx: register_context = mem_wbq_rdata.regctx;
    // let wb_alu_out: UIntX              = mem_wbq_rdata.alu_out;
    // let wb_mem_out: UIntX              = mem_wbq_rdata.mem_out;
    // let wb_csr_out: UIntX              = mem_wbq_rdata.csr_out;
    let wb_fwctx  : forwarding_context = mem_wbq_rdata.fwctx;
    let wb_wb_data: UIntX              = wb_fwctx.data;

    always_comb {
        mem_wbq_rready = 1;
    }

    always_ff (clk, rst) {
        if_reset {
            $display       ("reset!");
            if_pc           = 0;
            if_is_requested = 0;
            if_requested_pc = 0;
            clock_count     = 0;
            regfile[0]      = 0;
            regfile[31:1]   = 'x;
            mem_is_new      = 0;
        } else {
            $display   ("------------------ clock %0d", clock_count);
            clock_count = clock_count + 1;
            // fetch stage
            $display("Fetch Stage ---");
            if (reset_before_memstage) {
                if_is_requested = 0;
                if_pc           = if (mem_csr_is_trap) {
                    mem_csr_trap_vector
                } else if (mem_is_branch_hazard) {
                    mem_next_pc_expected
                } else {
                    0
                };
            } else {
                if (if_is_requested) {
                    if iresp.valid {
                        $display("  fetched: %h:%h", if_requested_pc, if_fetch_inst);
                        // TODO task? (function emits blocking assignment...)
                        if (ireq.ready & if_idq_wready_next) {
                            $display       ("  fetch req: %h", if_pc);
                            if_pc           = if_pc + 4;
                            if_is_requested = 1;
                            if_requested_pc = if_pc;
                        } else {
                            if_is_requested = 0;
                        }
                    }
                } else {
                    if (ireq.ready & if_idq_wready_next) {
                        $display       ("  fetch req: %h", if_pc);
                        if_pc           = if_pc + 4;
                        if_is_requested = 1;
                        if_requested_pc = if_pc;
                    } else {
                        if_is_requested = 0;
                    }
                }
            }


            // decode stage
            $display("Decode Stage ---");
            if (if_idq_rvalid) {
                $display("  %h:%h", if_idq_rdata.addr, if_idq_rdata.instbit);
                $display("  is_legal  : %2d", id_info.ctrl.is_legal);
                $display("  alu_cmd   : %2d", id_info.ctrl.alu_cmd);
                $display("  br_cmd    : %2d", id_info.ctrl.br_cmd);
                $display("  is_signed : %2d", id_info.ctrl.is_signed);
                $display("  op1_sel   : %2d", id_info.ctrl.op1_sel);
                $display("  op2_sel   : %2d", id_info.ctrl.op2_sel);
                $display("  use_rs2   : %2d", id_info.ctrl.use_rs2);
                $display("  mem_cmd   : %2d", id_info.ctrl.mem_cmd);
                $display("  mem_size  : %2d", id_info.ctrl.mem_size);
                $display("  csr_cmd   : %2d", id_info.ctrl.csr_cmd);
                $display("  rf_wen    : %2d", id_info.ctrl.rf_wen);
                $display("  wb_sel    : %2d", id_info.ctrl.wb_sel);
            }

            // ds stage
            $display("Data Stage ---");
            if (id_dsq_rvalid) {
                $display("  %h:%h", ds_info.addr, ds_info.instbit);
                $display("  stall     : %d", ds_stall);
                $display("  op1       : %h", ds_op1);
                $display("  op2       : %h", ds_op2);
                $display("  rs2       : %h", ds_rs2);
            }

            // exe stage
            $display("Exe Stage ---");
            if (ds_exeq_rvalid) {
                $display("  %h:%h", exe_info.addr, exe_info.instbit);
                $display("  stall     : %d", !exe_memq_wvalid | !exe_memq_wready);
                $display("  alu_cmd   : %2d", exe_info.ctrl.alu_cmd);
                $display("  op1       : %h", exe_op1);
                $display("  op2       : %h", exe_op2);
                $display("  alu_out   : %h", exe_alu_out);
            }
            // mem stage
            $display("Mem Stage ---");
            if (mem_valid) {
                mem_is_new = exe_memq_rready;
                $display  ("  %h:%h", mem_info.addr, mem_info.instbit);
                $display  ("  mu_stall     : %d", mem_memunit_stall);
                $display  ("  mem_cmd      : %d", mem_info.ctrl.mem_cmd);
                $display  ("  mem_out      : %h", mem_mem_rdata);
                $display  ("  cu_stall     : %d", mem_csrunit_stall);
                $display  ("  csr_cmd      : %d", mem_info.ctrl.csr_cmd);
                if (mem_csr_is_trap) {
                    $display("  csr hazard: %h", mem_csr_trap_vector);
                } else if (mem_is_branch_hazard) {
                    $display("  branch hazard: expected:%h actual:%h", mem_next_pc_expected, mem_next_pc_actual);
                }
            } else {
                mem_is_new = 1;
            }

            $display("Wb Stage---");
            if (wb_valid) {
                $display("  %h:%h", wb_info.addr, wb_info.instbit);
                if (wb_info.ctrl.rf_wen & wb_regctx.rd_addr != 0) {
                    $display                  ("  writebacked [%d] <= %h", wb_regctx.rd_addr, wb_wb_data);
                    regfile[wb_regctx.rd_addr] = wb_wb_data;
                }
            }
        }
    }

    inst decode_unit: decoder (
        instbit: if_idq_rdata.instbit,
        ctrl   : id_info.ctrl        ,
    );

    inst exe_alu: alu (
        cmd      : exe_info.ctrl.alu_cmd  ,
        is_signed: exe_info.ctrl.is_signed,
        op1_data : exe_op1                ,
        op2_data : exe_op2                ,
        result   : exe_alu_out            ,
    );

    inst exe_alubr: alubr (
        cmd      : exe_info.ctrl.br_cmd   ,
        is_signed: exe_info.ctrl.is_signed,
        op1_data : exe_op1                ,
        op2_data : exe_op2                ,
        take     : exe_br_taken           ,
    );

    inst ds_immdec: imm_decoder (
        data : ds_info.instbit,
        imm_i: ds_imm_i       ,
        imm_s: ds_imm_s       ,
        imm_b: _              ,
        imm_j: ds_imm_j       ,
        imm_u: ds_imm_u       ,
        imm_z: ds_imm_z       ,
    );

    inst exe_immdec: imm_decoder (
        data : exe_info.instbit,
        imm_i: _               ,
        imm_s: _               ,
        imm_b: exe_imm_b       ,
        imm_j: _               ,
        imm_u: _               ,
        imm_z: _               ,
    );

    inst mem_memunit: memunit (
        clk                        ,
        rst                        ,
        dreq                       ,
        dresp                      ,
        valid   : mem_valid        ,
        is_new  : mem_is_new       ,
        ctrl    : mem_info.ctrl    ,
        rs2     : mem_rs2          ,
        addr    : mem_alu_out      ,
        is_stall: mem_memunit_stall,
        mem_out : mem_mem_rdata    ,
    );

    inst mem_csrunit: csrunit (
        clk                                 ,
        rst                                 ,
        valid      : mem_valid              ,
        is_new     : mem_is_new             ,
        pc         : mem_info.addr          ,
        cmd        : mem_info.ctrl.csr_cmd  ,
        csr_addr   : mem_info.instbit[31:20],
        op1_data   : mem_alu_out            ,
        csr_rdata  : mem_csr_rdata          ,
        is_stall   : mem_csrunit_stall      ,
        is_trap    : mem_csr_is_trap        ,
        trap_vector: mem_csr_trap_vector    ,
    );

    inst fifo_fetch_decode: fifo_f #(
        Width   : 3          ,
        DataType: if_idq_type,
    ) (
        clk                                  ,
        rst                                  ,
        rst_pos    : reset_before_memstage   ,
        wready     : if_idq_wready_do_not_use,
        wready_next: if_idq_wready_next      ,
        wvalid     : if_idq_wvalid           ,
        wdata      : if_idq_wdata            ,
        rready     : if_idq_rready           ,
        rvalid     : if_idq_rvalid           ,
        rdata      : if_idq_rdata            ,
    );

    inst fifo_decode_ds: fifo #(
        Width   : 0          ,
        DataType: id_dsq_type,
    ) (
        clk                           ,
        rst                           ,
        rst_pos: reset_before_memstage,
        wready : id_dsq_wready        ,
        wvalid : id_dsq_wvalid        ,
        wdata  : id_dsq_wdata         ,
        rready : id_dsq_rready        ,
        rvalid : id_dsq_rvalid        ,
        rdata  : id_dsq_rdata         ,
    );

    inst fifo_ds_exe: fifo #(
        Width   : 0           ,
        DataType: ds_exeq_type,
    ) (
        clk                           ,
        rst                           ,
        rst_pos: reset_before_memstage,
        wready : ds_exeq_wready       ,
        wvalid : ds_exeq_wvalid       ,
        wdata  : ds_exeq_wdata        ,
        rready : ds_exeq_rready       ,
        rvalid : ds_exeq_rvalid       ,
        rdata  : ds_exeq_rdata        ,
    );

    inst fifo_exe_mem: fifo #(
        Width   : 0            ,
        DataType: exe_memq_type,
    ) (
        clk                                              ,
        rst                                              ,
        rst_pos: 0                                       ,
        wready : exe_memq_wready                         ,
        wvalid : exe_memq_wvalid & !reset_before_memstage,
        wdata  : exe_memq_wdata                          ,
        rready : exe_memq_rready                         ,
        rvalid : exe_memq_rvalid                         ,
        rdata  : exe_memq_rdata                          ,
    );

    inst fifo_mem_wb: fifo #(
        Width   : 0           ,
        DataType: mem_wbq_type,
    ) (
        clk                    ,
        rst                    ,
        rst_pos: 0             ,
        wready : mem_wbq_wready,
        wvalid : mem_wbq_wvalid,
        wdata  : mem_wbq_wdata ,
        rready : mem_wbq_rready,
        rvalid : mem_wbq_rvalid,
        rdata  : mem_wbq_rdata ,
    );
}
