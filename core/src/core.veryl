import eei::*;
import corectrl::*;

module core (
    clk     : input   clock                                    ,
    rst     : input   reset                                    ,
    i_membus: modport membus_if::<ILEN, XLEN>::master          ,
    d_membus: modport membus_if::<MEM_DATA_WIDTH, XLEN>::master,
) {

    // 命令が分岐命令かどうかを判定する
    function inst_is_br (
        ctrl: input InstCtrl,
    ) -> logic    {
        return ctrl.itype == InstType::B;
    }

    // ifのFIFOのデータ型
    struct if_fifo_type {
        addr: Addr,
        bits: Inst,
    }

    struct exq_type {
        addr: Addr    ,
        bits: Inst    ,
        ctrl: InstCtrl,
        imm : UIntX   ,
    }

    struct memq_type {
        addr      : Addr       ,
        bits      : Inst       ,
        ctrl      : InstCtrl   ,
        imm       : UIntX      ,
        alu_result: UIntX      ,
        rs1_addr  : logic   <5>,
        rs1_data  : UIntX      ,
        rs2_data  : UIntX      ,
        br_taken  : logic      ,
        jump_addr : Addr       ,
    }

    struct wbq_type {
        addr      : Addr    ,
        bits      : Inst    ,
        ctrl      : InstCtrl,
        imm       : UIntX   ,
        alu_result: UIntX   ,
        mem_rdata : UIntX   ,
        csr_rdata : UIntX   ,
    }

    // 命令メモリ -> IFのFIFO
    var if_fifo_wready: logic       ;
    var if_fifo_wvalid: logic       ;
    var if_fifo_wdata : if_fifo_type;
    var if_fifo_rready: logic       ;
    var if_fifo_rvalid: logic       ;
    var if_fifo_rdata : if_fifo_type;

    // ID -> EXのFIFO
    var exq_wready: logic   ;
    var exq_wvalid: logic   ;
    var exq_wdata : exq_type;
    var exq_rready: logic   ;
    var exq_rvalid: logic   ;
    var exq_rdata : exq_type;

    // EX -> MEMのFIFO
    var memq_wready: logic    ;
    var memq_wvalid: logic    ;
    var memq_wdata : memq_type;
    var memq_rready: logic    ;
    var memq_rvalid: logic    ;
    var memq_rdata : memq_type;

    // MEM -> WBのFIFO
    var wbq_wready: logic   ;
    var wbq_wvalid: logic   ;
    var wbq_wdata : wbq_type;
    var wbq_rready: logic   ;
    var wbq_rvalid: logic   ;
    var wbq_rdata : wbq_type;


    // #@@range_begin(mark_if)
    ///////////////////////////////// IF Stage /////////////////////////////////

    var if_pc          : Addr ;
    ...
    // #@@range_end(mark_if)
    var if_is_requested: logic; // フェッチ中かどうか
    var if_pc_requested: Addr ; // 要求したアドレス

    let if_pc_next: Addr = if_pc + 4;

    var control_hazard        : logic;
    var control_hazard_pc_next: Addr ;

    // フェッチした命令を格納するFIFO
    inst if_fifo: fifo #(
        DATA_TYPE: if_fifo_type,
        WIDTH    : 3           ,
    ) (
        clk                   ,
        rst                   ,
        flush : control_hazard,
        wready: if_fifo_wready,
        wvalid: if_fifo_wvalid,
        wdata : if_fifo_wdata ,
        rready: if_fifo_rready,
        rvalid: if_fifo_rvalid,
        rdata : if_fifo_rdata ,
    );

    // 命令フェッチ処理
    always_comb {
        // FIFOに2個以上空きがあるとき、命令をフェッチする
        i_membus.valid = if_fifo.wready_two;
        i_membus.addr  = if_pc;
        i_membus.wen   = 0;
        i_membus.wdata = 'x; // wdataは使用しない
    }

    always_ff {
        if_reset {
            if_pc           = 0;
            if_is_requested = 0;
            if_pc_requested = 0;
            if_fifo_wvalid  = 0;
            if_fifo_wdata   = 0;
        } else {
            if control_hazard {
                if_pc           = control_hazard_pc_next;
                if_is_requested = 0;
                if_fifo_wvalid  = 0;
            } else {
                if if_is_requested {
                    if i_membus.rvalid {
                        if_is_requested = i_membus.ready && i_membus.valid;
                        if i_membus.ready && i_membus.valid {
                            if_pc           = if_pc_next;
                            if_pc_requested = if_pc;
                        }
                    }
                } else {
                    if i_membus.ready && i_membus.valid {
                        if_is_requested = 1;
                        if_pc           = if_pc_next;
                        if_pc_requested = if_pc;
                    }
                }
                // IFのFIFOの制御
                if if_is_requested && i_membus.rvalid {
                    if_fifo_wvalid     = 1;
                    if_fifo_wdata.addr = if_pc_requested;
                    if_fifo_wdata.bits = i_membus.rdata;
                } else {
                    if if_fifo_wvalid && if_fifo_wready {
                        if_fifo_wvalid = 0;
                    }
                }
            }
        }
    }

    // #@@range_begin(mark_id)
    ///////////////////////////////// ID Stage /////////////////////////////////
    // #@@range_end(mark_id)

    let ids_valid    : logic    = if_fifo_rvalid;
    // #@@range_begin(id_is_new)
    @<del>|var ids_is_new   : logic   ;|
    // #@@range_end(id_is_new)
    let ids_pc       : Addr     = if_fifo_rdata.addr;
    let ids_inst_bits: Inst     = if_fifo_rdata.bits;
    var ids_ctrl     : InstCtrl;
    var ids_imm      : UIntX   ;

    inst decoder: inst_decoder (
        bits: ids_inst_bits,
        ctrl: ids_ctrl     ,
        imm : ids_imm      ,
    );

    // #@@range_begin(always_comb_id)
    always_comb {
        // ID -> EX
        if_fifo_rready = exq_wready;
        exq_wvalid     = if_fifo_rvalid;
        exq_wdata.addr = if_fifo_rdata.addr;
        exq_wdata.bits = if_fifo_rdata.bits;
        exq_wdata.ctrl = ids_ctrl;
        exq_wdata.imm  = ids_imm;
    }
    // #@@range_end(always_comb_id)

    // #@@range_begin(mark_ex)
    ///////////////////////////////// EX Stage /////////////////////////////////
    // #@@range_end(mark_ex)

    // #@@range_begin(var_ex)
    let exs_valid    : logic    = exq_rvalid;
    let exs_pc       : Addr     = exq_rdata.addr;
    let exs_inst_bits: Inst     = exq_rdata.bits;
    let exs_ctrl     : InstCtrl = exq_rdata.ctrl;
    let exs_imm      : UIntX    = exq_rdata.imm;
    // #@@range_end(var_ex)

    // レジスタ
    var regfile: UIntX<32>;

    // #@@range_begin(ex_prefix)
    // レジスタ番号
    let @<b>|exs_|rs1_addr: logic<5> = @<b>|exs|_inst_bits[19:15];
    let @<b>|exs_|rs2_addr: logic<5> = @<b>|exs|_inst_bits[24:20];

    // ソースレジスタのデータ
    let @<b>|exs_|rs1_data: UIntX = if @<b>|exs_|rs1_addr == 0 {
        0
    } else {
        regfile[@<b>|exs_|rs1_addr]
    };
    let @<b>|exs_|rs2_data: UIntX = if @<b>|exs_|rs2_addr == 0 {
        0
    } else {
        regfile[@<b>|exs_|rs2_addr]
    };

    // ALU
    var @<b>|exs_|op1       : UIntX;
    var @<b>|exs_|op2       : UIntX;
    var @<b>|exs_|alu_result: UIntX;

    always_comb {
        case @<b>|exs|_ctrl.itype {
            InstType::R, InstType::B: {
                                          @<b>|exs_|op1 = @<b>|exs_|rs1_data;
                                          @<b>|exs_|op2 = @<b>|exs_|rs2_data;
                                      }
            InstType::I, InstType::S: {
                                          @<b>|exs_|op1 = @<b>|exs_|rs1_data;
                                          @<b>|exs_|op2 = @<b>|exs|_imm;
                                      }
            InstType::U, InstType::J: {
                                          @<b>|exs_|op1 = @<b>|exs|_pc;
                                          @<b>|exs_|op2 = @<b>|exs|_imm;
                                      }
            default: {
                         @<b>|exs_|op1 = 'x;
                         @<b>|exs_|op2 = 'x;
                     }
        }
    }

    inst alum: alu (
        ctrl  : @<b>|exs|_ctrl      ,
        op1   : @<b>|exs_|op1       ,
        op2   : @<b>|exs_|op2       ,
        result: @<b>|exs_|alu_result,
    );

    var @<b>|exs_|brunit_take: logic;

    inst bru: brunit (
        funct3: @<b>|exs|_ctrl.funct3,
        op1   : @<b>|exs_|op1        ,
        op2   : @<b>|exs_|op2        ,
        take  : @<b>|exs_|brunit_take,
    );
    // #@@range_end(ex_prefix)

    // #@@range_begin(always_comb_ex)
    always_comb {
        // EX -> MEM
        exq_rready            = memq_wready;
        memq_wvalid           = exq_rvalid;
        memq_wdata.addr       = exq_rdata.addr;
        memq_wdata.bits       = exq_rdata.bits;
        memq_wdata.ctrl       = exq_rdata.ctrl;
        memq_wdata.imm        = exq_rdata.imm;
        memq_wdata.rs1_addr   = exs_rs1_addr;
        memq_wdata.rs1_data   = exs_rs1_data;
        memq_wdata.rs2_data   = exs_rs2_data;
        memq_wdata.alu_result = exs_alu_result;
        @<balloon>{ジャンプ命令、または、分岐命令かつ分岐が成立するとき、1にする}
        memq_wdata.br_taken   = exs_ctrl.is_jump || inst_is_br(exs_ctrl) && exs_brunit_take;
        memq_wdata.jump_addr  = if inst_is_br(exs_ctrl) {
            exs_pc + exs_imm @<balloon>{分岐命令の分岐先アドレス}
        } else {
            exs_alu_result @<balloon>{ジャンプ命令のジャンプ先アドレス}
        };
    }
    // #@@range_end(always_comb_ex)

    // #@@range_begin(mark_mem)
    ///////////////////////////////// MEM Stage /////////////////////////////////
    // #@@range_end(mark_mem)

    // #@@range_begin(var_mem)
    var mems_is_new   : logic      ;
    let mems_valid    : logic       = memq_rvalid;
    let mems_pc       : Addr        = memq_rdata.addr;
    let mems_inst_bits: Inst        = memq_rdata.bits;
    let mems_ctrl     : InstCtrl    = memq_rdata.ctrl;
    let mems_rd_addr  : logic   <5> = mems_inst_bits[11:7];
    // #@@range_end(var_mem)

    // #@@range_begin(mem_prefix1)
    assign control_hazard         = @<b>|mems|_valid && (csru_raise_trap || @<b>|mems|_ctrl.is_jump || @<b>|memq_rdata.|br_taken);
    assign control_hazard_pc_next = if csru_raise_trap {
        csru_trap_vector
    } else {
        @<b>|memq_rdata.|jump_addr
    };
    // #@@range_end(mem_prefix1)

    // #@@range_begin(mem_is_new)
    always_ff {
        if_reset {
            @<b>|mems|_is_new = 0;
        } else {
            if memq_rvalid {
                @<b>|mems|_is_new = memq_rready;
            } else {
                @<b>|mems|_is_new = 1;
            }
        }
    }
    // #@@range_end(mem_is_new)

    // #@@range_begin(mem_prefix2)
    var memu_rdata: UIntX;
    var memu_stall: logic;

    inst memu: memunit (
        clk                          ,
        rst                          ,
        valid : @<b>|mems|_valid           ,
        is_new: @<b>|mems|_is_new          ,
        ctrl  : @<b>|mems|_ctrl            ,
        addr  : @<b>|memq_rdata.|alu_result,
        rs2   : @<b>|memq_rdata.|rs2_data  ,
        rdata : memu_rdata           ,
        stall : memu_stall           ,
        membus: d_membus             ,
    );

    var csru_rdata      : UIntX;
    var csru_raise_trap : logic;
    var csru_trap_vector: Addr ;

    inst csru: csrunit (
        clk                            ,
        rst                            ,
        valid   : @<b>|mems|_valid           ,
        pc      : @<b>|mems|_pc              ,
        ctrl    : @<b>|mems|_ctrl            ,
        rd_addr : @<b>|mems|_rd_addr         ,
        csr_addr: @<b>|mems|_inst_bits[31:20],
        rs1     : if @<b>|mems|_ctrl.funct3[2] == 1 && @<b>|mems|_ctrl.funct3[1:0] != 0 {
            {1'b0 repeat XLEN - $bits(@<b>|memq_rdata.|rs1_addr), @<b>|memq_rdata.|rs1_addr} // rs1を0で拡張する
        } else {
            @<b>|memq_rdata.|rs1_data
        },
        rdata      : csru_rdata,
        raise_trap : csru_raise_trap,
        trap_vector: csru_trap_vector,
    );
    // #@@range_end(mem_prefix2)

    // #@@range_begin(always_comb_mem)
    always_comb {
        // MEM -> WB
        memq_rready          = wbq_wready && !memu_stall;
        wbq_wvalid           = memq_rvalid && !memu_stall;
        wbq_wdata.addr       = memq_rdata.addr;
        wbq_wdata.bits       = memq_rdata.bits;
        wbq_wdata.ctrl       = memq_rdata.ctrl;
        wbq_wdata.imm        = memq_rdata.imm;
        wbq_wdata.alu_result = memq_rdata.alu_result;
        wbq_wdata.mem_rdata  = memu_rdata;
        wbq_wdata.csr_rdata  = csru_rdata;
    }
    // #@@range_end(always_comb_mem)

    // #@@range_begin(mark_wb)
    ///////////////////////////////// WB Stage /////////////////////////////////
    // #@@range_end(mark_wb)

    // #@@range_begin(var_wb)
    let wbs_valid    : logic    = wbq_rvalid;
    let wbs_pc       : Addr     = wbq_rdata.addr;
    let wbs_inst_bits: Inst     = wbq_rdata.bits;
    let wbs_ctrl     : InstCtrl = wbq_rdata.ctrl;
    let wbs_imm      : UIntX    = wbq_rdata.imm;
    // #@@range_end(var_wb)

    // #@@range_begin(wb_prefix)
    let @<b>|wbs_|rd_addr: logic<5> = @<b>|wbs|_inst_bits[11:7];
    let @<b>|wbs_|wb_data: UIntX    = if @<b>|wbs|_ctrl.is_lui {
        @<b>|wbs|_imm
    } else if @<b>|wbs|_ctrl.is_jump {
        @<b>|wbs_pc| + 4
    } else if @<b>|wbs|_ctrl.is_load {
        @<b>|wbq_rdata.|mem_rdata
    } else if @<b>|wbs|_ctrl.is_csr {
        @<b>|wbq_rdata.|csr_rdata
    } else {
        @<b>|wbq_rdata.|alu_result
    };

    always_ff {
        if @<b>|wbs|_valid && @<b>|wbs|_ctrl.rwb_en {
            regfile[@<b>|wbs_|rd_addr] = @<b>|wbs_|wb_data;
        }
    }
    // #@@range_end(wb_prefix)

    // #@@range_begin(always_comb_wb)
    always_comb {
        // WB -> END
        wbq_rready = 1;
    }
    // #@@range_end(always_comb_wb)

    // #@@range_begin(debug)
    ///////////////////////////////// DEBUG /////////////////////////////////
    var clock_count: u64;

    always_ff {
        if_reset {
            clock_count = 1;
        } else {
            clock_count = clock_count + 1;

            $display("");
            $display("# %d", clock_count);

            $display("IF ------");
            $display("     pc : %h", if_pc);
            $display(" is req : %b", if_is_requested);
            $display(" pc req : %h", if_pc_requested);
            $display("ID ------");
            if ids_valid {
                $display("  %h : %h", ids_pc, if_fifo_rdata.bits);
                $display("  itype : %b", ids_ctrl.itype);
                $display("  imm   : %h", ids_imm);
            }
            $display("EX -----");
            if exs_valid {
                $display("  %h : %h", exq_rdata.addr, exq_rdata.bits);
                $display("  op1     : %h", exs_op1);
                $display("  op2     : %h", exs_op2);
                $display("  alu     : %h", exs_alu_result);
                if inst_is_br(exs_ctrl) {
                    $display("  br take : ", exs_brunit_take);
                }
            }
            $display("MEM -----");
            if mems_valid {
                $display("  %h : %h", memq_rdata.addr, memq_rdata.bits);
                $display("  mem stall : %b", memu_stall);
                $display("  mem rdata : %h", memu_rdata);
                if mems_ctrl.is_csr {
                    $display("  csr rdata : %h", csru_rdata);
                    $display("  csr trap  : %b", csru_raise_trap);
                    $display("  csr vec   : %h", csru_trap_vector);
                }
                if memq_rdata.br_taken {
                    $display("  JUMP TO   : %h", memq_rdata.jump_addr);
                }
            }
            $display("WB ----");
            if wbs_valid {
                $display("  %h : %h", wbq_rdata.addr, wbq_rdata.bits);
                if wbs_ctrl.rwb_en {
                    $display("  reg[%d] <= %h", wbs_rd_addr, wbs_wb_data);
                }
            }
        }
    }
    // #@@range_end(debug)

    ///////////////////////////////// FIFO /////////////////////////////////

    inst id_ex_fifo: fifo #(
        DATA_TYPE: exq_type,
        WIDTH    : 1       ,
    ) (
        clk                   ,
        rst                   ,
        flush : control_hazard,
        wready: exq_wready    ,
        wvalid: exq_wvalid    ,
        wdata : exq_wdata     ,
        rready: exq_rready    ,
        rvalid: exq_rvalid    ,
        rdata : exq_rdata     ,
    );

    inst ex_mem_fifo: fifo #(
        DATA_TYPE: memq_type,
        WIDTH    : 1        ,
    ) (
        clk                   ,
        rst                   ,
        flush : control_hazard,
        wready: memq_wready   ,
        wvalid: memq_wvalid   ,
        wdata : memq_wdata    ,
        rready: memq_rready   ,
        rvalid: memq_rvalid   ,
        rdata : memq_rdata    ,
    );

    inst mem_wb_fifo: fifo #(
        DATA_TYPE: wbq_type,
        WIDTH    : 1       ,
    ) (
        clk               ,
        rst               ,
        flush : 0         ,
        wready: wbq_wready,
        wvalid: wbq_wvalid,
        wdata : wbq_wdata ,
        rready: wbq_rready,
        rvalid: wbq_rvalid,
        rdata : wbq_rdata ,
    );
}
