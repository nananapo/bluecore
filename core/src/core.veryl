import eei::*;
import corectrl::*;

module core (
    clk     : input   clock                                    ,
    rst     : input   reset                                    ,
    i_membus: modport membus_if::<ILEN, XLEN>::master          ,
    d_membus: modport membus_if::<MEM_DATA_WIDTH, XLEN>::master,
) {

    // 命令が分岐命令かどうかを判定する
    function inst_is_br (
        ctrl: input InstCtrl,
    ) -> logic    {
        return ctrl.itype == InstType::B;
    }

    // ifのFIFOのデータ型
    struct if_fifo_type {
        addr: Addr,
        bits: Inst,
    }

    // FIFOの制御用レジスタ
    var if_fifo_wready: logic       ;
    var if_fifo_wvalid: logic       ;
    var if_fifo_wdata : if_fifo_type;
    var if_fifo_rready: logic       ;
    var if_fifo_rvalid: logic       ;
    var if_fifo_rdata : if_fifo_type;

    var if_pc          : Addr ;
    var if_is_requested: logic; // フェッチ中かどうか
    var if_pc_requested: Addr ; // 要求したアドレス

    let if_pc_next: Addr = if_pc + 4;

    var control_hazard        : logic;
    var control_hazard_pc_next: Addr ;

    // フェッチした命令を格納するFIFO
    inst if_fifo: fifo #(
        DATA_TYPE: if_fifo_type,
        WIDTH    : 3           ,
    ) (
        clk                   ,
        rst                   ,
        flush : control_hazard,
        wready: if_fifo_wready,
        wvalid: if_fifo_wvalid,
        wdata : if_fifo_wdata ,
        rready: if_fifo_rready,
        rvalid: if_fifo_rvalid,
        rdata : if_fifo_rdata ,
    );

    // 命令フェッチ処理
    always_comb {
        // FIFOに2個以上空きがあるとき、命令をフェッチする
        i_membus.valid = if_fifo.wready_two;
        i_membus.addr  = if_pc;
        i_membus.wen   = 0;
        i_membus.wdata = 'x; // wdataは使用しない

        // memunitが処理中ではないとき、FIFOから命令を取り出していい
        if_fifo_rready = !memu_stall;
    }

    always_ff {
        if_reset {
            if_pc           = 0;
            if_is_requested = 0;
            if_pc_requested = 0;
            if_fifo_wvalid  = 0;
            if_fifo_wdata   = 0;
        } else {
            if control_hazard {
                if_pc           = control_hazard_pc_next;
                if_is_requested = 0;
                if_fifo_wvalid  = 0;
            } else {
                if if_is_requested {
                    if i_membus.rvalid {
                        if_is_requested = i_membus.ready && i_membus.valid;
                        if i_membus.ready && i_membus.valid {
                            if_pc           = if_pc_next;
                            if_pc_requested = if_pc;
                        }
                    }
                } else {
                    if i_membus.ready && i_membus.valid {
                        if_is_requested = 1;
                        if_pc           = if_pc_next;
                        if_pc_requested = if_pc;
                    }
                }
                // IFのFIFOの制御
                if if_is_requested && i_membus.rvalid {
                    if_fifo_wvalid     = 1;
                    if_fifo_wdata.addr = if_pc_requested;
                    if_fifo_wdata.bits = i_membus.rdata;
                } else {
                    if if_fifo_wvalid && if_fifo_wready {
                        if_fifo_wvalid = 0;
                    }
                }
            }
        }
    }

    let inst_valid : logic    = if_fifo_rvalid;
    var inst_is_new: logic   ; // 命令が現在のクロックで供給されたかどうか
    let inst_pc    : Addr     = if_fifo_rdata.addr;
    let inst_bits  : Inst     = if_fifo_rdata.bits;
    var inst_ctrl  : InstCtrl;
    var inst_imm   : UIntX   ;

    inst decoder: inst_decoder (
        bits: inst_bits,
        ctrl: inst_ctrl,
        imm : inst_imm ,
    );

    // レジスタ
    var regfile: UIntX<32>;

    // レジスタ番号
    let rs1_addr: logic<5> = inst_bits[19:15];
    let rs2_addr: logic<5> = inst_bits[24:20];

    // ソースレジスタのデータ
    let rs1_data: UIntX = if rs1_addr == 0 {
        0
    } else {
        regfile[rs1_addr]
    };
    let rs2_data: UIntX = if rs2_addr == 0 {
        0
    } else {
        regfile[rs2_addr]
    };

    // ALU
    var op1       : UIntX;
    var op2       : UIntX;
    var alu_result: UIntX;

    always_comb {
        case inst_ctrl.itype {
            InstType::R, InstType::B: {
                                          op1 = rs1_data;
                                          op2 = rs2_data;
                                      }
            InstType::I, InstType::S: {
                                          op1 = rs1_data;
                                          op2 = inst_imm;
                                      }
            InstType::U, InstType::J: {
                                          op1 = inst_pc;
                                          op2 = inst_imm;
                                      }
            default: {
                         op1 = 'x;
                         op2 = 'x;
                     }
        }
    }

    inst alum: alu (
        ctrl  : inst_ctrl ,
        op1               ,
        op2               ,
        result: alu_result,
    );

    var brunit_take: logic;

    inst bru: brunit (
        funct3: inst_ctrl.funct3,
        op1                     ,
        op2                     ,
        take  : brunit_take     ,
    );

    assign control_hazard         = inst_valid && (inst_ctrl.is_jump || inst_is_br(inst_ctrl) && brunit_take);
    assign control_hazard_pc_next = if inst_is_br(inst_ctrl) {
        inst_pc + inst_imm
    } else {
        alu_result
    };

    always_ff {
        if_reset {
            inst_is_new = 0;
        } else {
            if if_fifo_rvalid {
                inst_is_new = if_fifo_rready;
            } else {
                inst_is_new = 1;
            }
        }
    }

    var memu_rdata: UIntX;
    var memu_stall: logic;

    inst memu: memunit (
        clk                ,
        rst                ,
        valid : inst_valid ,
        is_new: inst_is_new,
        ctrl  : inst_ctrl  ,
        addr  : alu_result ,
        rs2   : rs2_data   ,
        rdata : memu_rdata ,
        stall : memu_stall ,
        membus: d_membus   ,
    );

    var csru_rdata: UIntX;

    inst csru: csrunit (
        clk                       ,
        rst                       ,
        valid   : inst_valid      ,
        ctrl    : inst_ctrl       ,
        csr_addr: inst_bits[31:20],
        rs1     : if inst_ctrl.funct3[2] == 1 && inst_ctrl.funct3[1:0] != 0 {
            {1'b0 repeat XLEN - $bits(rs1_addr), rs1_addr} // rs1を0で拡張する
        } else {
            rs1_data
        },
        rdata: csru_rdata                                                                                                         ,
    );

    let rd_addr: logic<5> = inst_bits[11:7];
    let wb_data: UIntX    = if inst_ctrl.is_lui {
        inst_imm
    } else if inst_ctrl.is_jump {
        inst_pc + 4
    } else if inst_ctrl.is_load {
        memu_rdata
    } else if inst_ctrl.is_csr {
        csru_rdata
    } else {
        alu_result
    };

    always_ff {
        if inst_valid && if_fifo_rready && inst_ctrl.rwb_en {
            regfile[rd_addr] = wb_data;
        }
    }

    var clock_count: u64;

    always_ff {
        if_reset {
            clock_count = 1;
        } else {
            clock_count = clock_count + 1;
            if inst_valid {
                $display("# %d", clock_count);
                $display("%h : %h", inst_pc, inst_bits);
                $display("  itype     : %b", inst_ctrl.itype);
                $display("  imm       : %h", inst_imm);
                $display("  rs1[%d]   : %h", rs1_addr, rs1_data);
                $display("  rs2[%d]   : %h", rs2_addr, rs2_data);
                $display("  op1       : %h", op1);
                $display("  op2       : %h", op2);
                $display("  alu res   : %h", alu_result);
                $display("  mem stall : %b", memu_stall);
                $display("  mem rdata : %h", memu_rdata);
                if inst_ctrl.is_csr {
                    $display("  csr rdata : %h", csru_rdata);
                }
                if inst_is_br(inst_ctrl) {
                    $display("  br take   : %b", brunit_take);
                }
                if if_fifo_rready && inst_ctrl.rwb_en {
                    $display("  reg[%d] <= %h", rd_addr, wb_data);
                }
            }
        }
    }
}
