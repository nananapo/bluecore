module core (
    clk: input logic,
    rst: input logic,
) {

    import conf::*;
    import stage::*;

    // clock count
    var clock_count: u64;

    // memory
    var mem_ready : logic ;
    var mem_valid : logic ;
    var mem_wen   : logic ;
    var mem_addr  : Addr  ;
    var mem_wdata : UInt64;
    var mem_rvalid: logic ;
    var mem_rdata : UInt64;

    inst mem: $sv::memory (
        clk                           ,
        rst                           ,
        valid : mem_valid             ,
        wen   : mem_wen               ,
        addr  : mem_addr[16 + 3 - 1:3],
        wdata : mem_wdata             ,
        rvalid: mem_rvalid            ,
        rdata : mem_rdata             ,
    );

    // stage var
    struct if_idq_type {
        addr   : Addr,
        instbit: Inst,
    }
    var if_idq_wready: logic      ;
    var if_idq_wvalid: logic      ;
    var if_idq_wdata : if_idq_type;
    var if_idq_rready: logic      ;
    var if_idq_rvalid: logic      ;
    var if_idq_rdata : if_idq_type;

    struct stageinfo {
        addr   : Addr    ,
        instbit: Inst    ,
        ctrl   : InstCtrl,
    }

    struct id_exeq_type {
        info: stageinfo,
    }
    var id_exeq_wready: logic       ;
    var id_exeq_wvalid: logic       ;
    var id_exeq_wdata : id_exeq_type;
    var id_exeq_rready: logic       ;
    var id_exeq_rvalid: logic       ;
    var id_exeq_rdata : id_exeq_type;


    // TODO impl arbiter
    assign mem_ready = 1;

    // program counter
    var if_pc          : Addr ;
    var if_is_requested: logic;
    var if_requested_pc: Addr ;

    // fetch
    always_comb {
        mem_valid = if_idq_wready & mem_ready & (!if_is_requested | mem_rvalid);
        mem_addr  = if mem_rvalid {
            if_pc
        } else {
            if_requested_pc
        };
    }

    // fetched inst
    let if_fetch_inst: Inst = if (if_requested_pc[2] == 0) {
        mem_rdata[31:0]
    } else {
        mem_rdata[63:32]
    };

    // if -> id queue
    always_comb {
        if_idq_wvalid        = if_is_requested & mem_rvalid;
        if_idq_wdata.addr    = if_requested_pc;
        if_idq_wdata.instbit = if_fetch_inst;
        if_idq_rready        = id_exeq_wready;
    }

    /*
    // TODO veryl not support task (function emits blocking assignment...)
    task try_start_fetch() {
        if (mem_ready & if_idq_wready) {
            if_pc           = if_pc + 4;
            if_is_requested = 1;
            if_requested_pc = if_pc;
        } else {
            if_is_requested = 0;
        }
    }
    */

    // decode stage
    var id_info: stageinfo;
    always_comb {
        id_info.addr    = if_idq_rdata.addr;
        id_info.instbit = if_idq_rdata.instbit;
        // ctrl is assigned in decoder instance
    }

    // id -> exe queue
    always_comb {
        id_exeq_wvalid     = if_idq_rvalid;
        id_exeq_wdata.info = id_info;
        id_exeq_rready     = 1 & (!id_exeq_wvalid | 1);
    }

    // register
    var regfile: UIntX<32>;

    // exe stage
    let exe_info   : stageinfo = id_exeq_rdata.info;
    var exe_alu_out: UIntX    ;
    var exe_op1    : UIntX    ;
    var exe_op2    : UIntX    ;
    var exe_rs2    : UIntX    ;

    // const value
    let exe_rs1_addr: logic<5> = exe_info.instbit[19:15];
    let exe_rs2_addr: logic<5> = exe_info.instbit[24:20];
    var exe_imm_i   : UIntX   ;
    var exe_imm_s   : UIntX   ;
    var exe_imm_b   : UIntX   ;
    var exe_imm_j   : UIntX   ;
    var exe_imm_u   : UIntX   ;
    var exe_imm_z   : UIntX   ;

    always_comb {
        exe_op1 = case exe_info.ctrl.op1_sel {
            Op1Sel::RS1: regfile[exe_rs1_addr],
            Op1Sel::PC : exe_info.addr,
            Op1Sel::IMZ: exe_imm_z,
            default    : XLEN_X,
        };
        exe_op2 = case (exe_info.ctrl.op2_sel) {
            Op2Sel::RS2: regfile[exe_rs2_addr],
            Op2Sel::IMI: exe_imm_i,
            Op2Sel::IMS: exe_imm_s,
            Op2Sel::IMJ: exe_imm_j,
            Op2Sel::IMU: exe_imm_u,
            Op2Sel::IMZ: exe_imm_z,
            Op2Sel::NPC: 4,
            default    : XLEN_X,
        };
        exe_rs2 = regfile[exe_rs2_addr];
    }

    always_ff (clk, rst) {
        if_reset {
            $display       ("reset!");
            mem_wen         = 0;
            if_pc           = 0;
            if_is_requested = 0;
            if_requested_pc = 0;
            clock_count     = 0;
            regfile[0]      = 0;
            regfile[31:1]   = 'x;
        } else {
            $display   ("------------------ clock %0d", clock_count);
            clock_count = clock_count + 1;
            $display   ("Fetch Stage ---");
            // fetch stage
            if (if_is_requested) {
                if mem_rvalid {
                    $display("  fetched: %h:%h", if_requested_pc, if_fetch_inst);
                    // try_start_fetch();
                    if (mem_ready & if_idq_wready) {
                        if_pc           = if_pc + 4;
                        if_is_requested = 1;
                        if_requested_pc = if_pc;
                    } else {
                        if_is_requested = 0;
                    }
                }
            } else {
                // try_start_fetch();
                if (mem_ready & if_idq_wready) {
                    if_pc           = if_pc + 4;
                    if_is_requested = 1;
                    if_requested_pc = if_pc;
                } else {
                    if_is_requested = 0;
                }
            }

            // decode stage
            $display("Decode Stage ---");
            if (if_idq_rvalid) {
                $display("  %h:%h", if_idq_rdata.addr, if_idq_rdata.instbit);
                $display("  is_legal  : %2d", id_info.ctrl.is_legal);
                $display("  alu_cmd   : %2d", id_info.ctrl.alu_cmd);
                $display("  br_cmd    : %2d", id_info.ctrl.br_cmd);
                $display("  is_signed : %2d", id_info.ctrl.is_signed);
                $display("  op1_sel   : %2d", id_info.ctrl.op1_sel);
                $display("  op2_sel   : %2d", id_info.ctrl.op2_sel);
                $display("  use_rs2   : %2d", id_info.ctrl.use_rs2);
                $display("  mem_cmd   : %2d", id_info.ctrl.mem_cmd);
                $display("  mem_size  : %2d", id_info.ctrl.mem_size);
                $display("  csr_cmd   : %2d", id_info.ctrl.csr_cmd);
                $display("  rf_wen    : %2d", id_info.ctrl.rf_wen);
                $display("  wb_sel    : %2d", id_info.ctrl.wb_sel);
            }

            // exe stage
            $display("Exe Stage ---");
            if (id_exeq_rvalid) {
                $display("  %h:%h", exe_info.addr, exe_info.instbit);
                $display("  alu_cmd   : %2d", exe_info.ctrl.alu_cmd);
                $display("  op1       : %h", exe_op1);
                $display("  op2       : %h", exe_op2);
                $display("  alu_out   : %h", exe_alu_out);
            }
        }
    }

    inst decode_unit: decoder (
        instbit: if_idq_rdata.instbit,
        ctrl   : id_info.ctrl        ,
    );

    inst exe_alu: alu (
        cmd      : exe_info.ctrl.alu_cmd  ,
        is_signed: exe_info.ctrl.is_signed,
        op1_data : exe_op1                ,
        op2_data : exe_op2                ,
        result   : exe_alu_out            ,
    );

    inst exe_immdec: imm_decoder (
        data : exe_info.instbit,
        imm_i: exe_imm_i       ,
        imm_s: exe_imm_s       ,
        imm_b: exe_imm_b       ,
        imm_j: exe_imm_j       ,
        imm_u: exe_imm_u       ,
        imm_z: exe_imm_z       ,
    );

    inst fifo_fetch_decode: fifo #(
        Width       : 3          ,
        DataType    : if_idq_type,
        FutureWReady: 1          ,
    ) (
        clk                  ,
        rst                  ,
        wready: if_idq_wready,
        wvalid: if_idq_wvalid,
        wdata : if_idq_wdata ,
        rready: if_idq_rready,
        rvalid: if_idq_rvalid,
        rdata : if_idq_rdata ,
    );

    inst fifo_decode_exe: fifo #(
        Width   : 0           ,
        DataType: id_exeq_type,
    ) (
        clk                   ,
        rst                   ,
        wready: id_exeq_wready,
        wvalid: id_exeq_wvalid,
        wdata : id_exeq_wdata ,
        rready: id_exeq_rready,
        rvalid: id_exeq_rvalid,
        rdata : id_exeq_rdata ,
    );
}
