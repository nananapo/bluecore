module core (
    clk    : input   logic           ,
    rst    : input   logic           ,
    ibus_if: modport membus_if::slave,
    dbus_if: modport membus_if::slave,
) {
    import eei::*;
    import corectrl::*;

    // clock count
    var clock_count: u64;

    struct wb_context {
        valid: logic   ,
        addr : logic<5>,
        data : UIntX   ,
    }

    struct idq_type {
        addr    : Addr,
        instbits: Inst,
    }

    struct dwq_type {
        addr    : Addr    ,
        instbits: Inst    ,
        ctrl    : InstCtrl,
    }

    struct exq_type {
        addr    : Addr      ,
        instbits: Inst      ,
        ctrl    : InstCtrl  ,
        wbctx   : wb_context,
        op1     : UIntX     ,
        op2     : UIntX     ,
        rs2     : UIntX     ,
    }

    struct memq_type {
        addr     : Addr      ,
        instbits : Inst      ,
        ctrl     : InstCtrl  ,
        wbctx    : wb_context,
        alu_out  : UIntX     ,
        br_taken : logic     ,
        br_target: Addr      ,
        pc_next  : Addr      ,
        pc_inc   : Addr      ,
        rs2      : UIntX     ,
    }

    struct wbq_type {
        addr    : Addr      ,
        instbits: Inst      ,
        ctrl    : InstCtrl  ,
        wbctx   : wb_context,
    }

    var idq_wready_next: logic   ;
    var idq_wvalid     : logic   ;
    var idq_wdata      : idq_type;
    var idq_rready     : logic   ;
    var idq_rvalid     : logic   ;
    var idq_rdata      : idq_type;

    var dwq_wready: logic   ;
    var dwq_wvalid: logic   ;
    var dwq_wdata : dwq_type;
    var dwq_rready: logic   ;
    var dwq_rvalid: logic   ;
    var dwq_rdata : dwq_type;

    var exq_wready: logic   ;
    var exq_wvalid: logic   ;
    var exq_wdata : exq_type;
    var exq_rready: logic   ;
    var exq_rvalid: logic   ;
    var exq_rdata : exq_type;

    var memq_wready: logic    ;
    var memq_wvalid: logic    ;
    var memq_wdata : memq_type;
    var memq_rready: logic    ;
    var memq_rvalid: logic    ;
    var memq_rdata : memq_type;

    var wbq_wready: logic   ;
    var wbq_wvalid: logic   ;
    var wbq_wdata : wbq_type;
    var wbq_rready: logic   ;
    var wbq_rvalid: logic   ;
    var wbq_rdata : wbq_type;

    let dw_rs1_addr: logic<5> = dwq_rdata.instbits[19:15];
    let dw_rs2_addr: logic<5> = dwq_rdata.instbits[24:20];
    let dw_rd_addr : logic<5> = dwq_rdata.instbits[11:7];
    var dw_imm_i   : UIntX   ;
    var dw_imm_s   : UIntX   ;
    var dw_imm_j   : UIntX   ;
    var dw_imm_u   : UIntX   ;
    var dw_imm_z   : UIntX   ;

    var ex_imm_b: UIntX;

    // IF stage
    var if_pc          : Addr ;
    var if_is_requested: logic;
    var if_requested_pc: Addr ;

    always_comb {
        ibus_if.valid = idq_wready_next & (!if_is_requested | ibus_if.resp_valid);
        ibus_if.addr  = if_pc;
        ibus_if.wen   = 0;
        ibus_if.wdata = 'x;
        ibus_if.wmask = 0;
    }

    let if_inst_fetched: Inst = if if_requested_pc[2] == 0 {
        ibus_if.resp_rdata[31:0]
    } else {
        ibus_if.resp_rdata[63:32]
    };

    // IF stage -> ID stage
    always_comb {
        idq_wvalid         = if_is_requested & ibus_if.resp_valid;
        idq_wdata.addr     = if_requested_pc;
        idq_wdata.instbits = if_inst_fetched;
        idq_rready         = dwq_wready;
    }

    // ID stage -> DW stage
    always_comb {
        dwq_wvalid         = idq_rvalid;
        dwq_wdata.addr     = idq_rdata.addr;
        dwq_wdata.instbits = idq_rdata.instbits;
        dwq_rready         = !dwq_wvalid | exq_wready & exq_wvalid;
    }

    var dw_op1: UIntX;
    var dw_op2: UIntX;
    var dw_rs1: UIntX;
    var dw_rs2: UIntX;

    var regfile_rdata: UIntX<2>;

    always_comb {
        case dwq_rdata.ctrl.op1_sel {
            Op1Sel::RS1: dw_op1 = dw_rs1;
            Op1Sel::PC : dw_op1 = dwq_rdata.addr;
            Op1Sel::IMZ: dw_op1 = dw_imm_z;
            default    : dw_op1 = 'x;
        }
        case dwq_rdata.ctrl.op2_sel {
            Op2Sel::RS2: dw_op2 = dw_rs2;
            Op2Sel::IMI: dw_op2 = dw_imm_i;
            Op2Sel::IMS: dw_op2 = dw_imm_s;
            Op2Sel::IMJ: dw_op2 = dw_imm_j;
            Op2Sel::IMU: dw_op2 = dw_imm_u;
            default    : dw_op2 = 'x;
        }
    }

    // DW stage -> EX stage
    always_comb {
        exq_wvalid            = dwq_rvalid & !dw_stall;
        exq_wdata.addr        = dwq_rdata.addr;
        exq_wdata.instbits    = dwq_rdata.instbits;
        exq_wdata.ctrl        = dwq_rdata.ctrl;
        exq_wdata.op1         = dw_op1;
        exq_wdata.op2         = dw_op2;
        exq_wdata.rs2         = dw_rs2;
        exq_wdata.wbctx.valid = dwq_rdata.ctrl.wb_sel == WbSel::PC;
        exq_wdata.wbctx.addr  = if dwq_rdata.ctrl.rf_wen {
            dw_rd_addr
        } else {
            0
        };
        exq_wdata.wbctx.data = dwq_rdata.addr + 4;
        exq_rready           = !exq_rvalid | memq_wready & memq_wvalid;
    }

    var ex_alu_out : UIntX;
    var ex_br_taken: logic;

    // ex -> mem queue
    always_comb {
        memq_wvalid          = exq_rvalid & !ex_stall;
        memq_wdata.addr      = exq_rdata.addr;
        memq_wdata.instbits  = exq_rdata.instbits;
        memq_wdata.ctrl      = exq_rdata.ctrl;
        memq_wdata.rs2       = exq_rdata.rs2;
        memq_wdata.alu_out   = ex_alu_out;
        memq_wdata.br_taken  = ex_br_taken | exq_rdata.ctrl.br_cmd == BrCmd::JLI | exq_rdata.ctrl.br_cmd == BrCmd::JLR;
        memq_wdata.br_target = case exq_rdata.ctrl.br_cmd {
            BrCmd::JLI, BrCmd::JLR: ex_alu_out,
            default: exq_rdata.addr + ex_imm_b,
        } & (~1);
        memq_wdata.pc_inc      = exq_rdata.addr + 4;
        memq_wdata.pc_next     = dwq_rdata.addr;
        memq_wdata.wbctx.valid = exq_rdata.wbctx.valid | exq_rdata.ctrl.wb_sel == WbSel::ALU;
        memq_wdata.wbctx.addr  = exq_rdata.wbctx.addr;
        memq_wdata.wbctx.data  = if exq_rdata.wbctx.valid {
            exq_rdata.wbctx.data
        } else {
            ex_alu_out
        };
    }

    // mem stage
    var mem_is_new       : logic;
    var mem_memunit_stall: logic;
    var mem_mem_rdata    : UIntX;

    var mem_next_pc_expected: Addr ;
    var mem_is_branch_hazard: logic;

    var mem_csr_rdata      : UIntX;
    var mem_csrunit_stall  : logic;
    var mem_csr_is_trap    : logic;
    var mem_csr_trap_vector: Addr ;

    assign mem_next_pc_expected = if memq_rdata.ctrl.br_cmd == BrCmd::X | !memq_rdata.br_taken {
        memq_rdata.pc_inc
    } else {
        memq_rdata.br_target
    };

    assign mem_is_branch_hazard = memq_rvalid & mem_next_pc_expected != memq_rdata.pc_next;

    always_comb {
        memq_rready           = !mem_memunit_stall & !mem_csrunit_stall & 1;
        wbq_wvalid            = memq_rvalid & !mem_memunit_stall & !mem_csrunit_stall;
        wbq_wdata.addr        = memq_rdata.addr;
        wbq_wdata.instbits    = memq_rdata.instbits;
        wbq_wdata.ctrl        = memq_rdata.ctrl;
        wbq_wdata.wbctx.valid = 1;
        wbq_wdata.wbctx.addr  = memq_rdata.wbctx.addr;
        wbq_wdata.wbctx.data  = if memq_rdata.wbctx.valid {
            memq_rdata.wbctx.data
        } else if memq_rdata.ctrl.wb_sel == WbSel::MEM {
            mem_mem_rdata
        } else {
            mem_csr_rdata
        };
    }

    // wb stage
    assign wbq_rready = 1;

    var dw_dh_rs1: logic;
    var dw_dh_rs2: logic;

    let dw_stall             : logic = dw_dh_rs1 | dw_dh_rs2; // datahazard
    let ex_stall             : logic = !dwq_rvalid; // wait dw is valid
    let reset_before_memstage: logic = mem_is_branch_hazard | mem_csr_is_trap;

    always_ff (clk, rst) {
        if_reset {
            $display       ("reset!");
            clock_count     = 0;
            if_pc           = 0;
            if_is_requested = 0;
            if_requested_pc = 0;
            mem_is_new      = 0;
        } else {
            $display   ("------------------ clock %0d", clock_count);
            clock_count = clock_count + 1;
            $display   ("IF Stage ---");
            if reset_before_memstage {
                if_is_requested = 0;
                if_pc           = if mem_csr_is_trap {
                    mem_csr_trap_vector
                } else if mem_is_branch_hazard {
                    mem_next_pc_expected
                } else {
                    0
                };
            } else {
                if if_is_requested & ibus_if.resp_valid {
                    $display("  fetched: %h:%h", if_requested_pc, if_inst_fetched);
                }
                if ibus_if.ready & ibus_if.valid {
                    if_pc           = if_pc + 4;
                    if_is_requested = 1;
                    if_requested_pc = if_pc;
                    $display       ("  fetch req: %h", ibus_if.addr);
                } else {
                    if_is_requested = 0;
                }
            }
            $display("ID Stage ---");
            if idq_rvalid {
                $display("  %h:%h", idq_rdata.addr, idq_rdata.instbits);
                $display("  is_legal  : %2d", dwq_wdata.ctrl.is_legal);
                $display("  alu_cmd   : %2d", dwq_wdata.ctrl.alu_cmd);
                $display("  br_cmd    : %2d", dwq_wdata.ctrl.br_cmd);
                $display("  is_signed : %2d", dwq_wdata.ctrl.is_signed);
                $display("  op1_sel   : %2d", dwq_wdata.ctrl.op1_sel);
                $display("  op2_sel   : %2d", dwq_wdata.ctrl.op2_sel);
                $display("  use_rs2   : %2d", dwq_wdata.ctrl.use_rs2);
                $display("  mem_cmd   : %2d", dwq_wdata.ctrl.mem_cmd);
                $display("  mem_size  : %2d", dwq_wdata.ctrl.mem_size);
                $display("  csr_cmd   : %2d", dwq_wdata.ctrl.csr_cmd);
                $display("  rf_wen    : %2d", dwq_wdata.ctrl.rf_wen);
                $display("  wb_sel    : %2d", dwq_wdata.ctrl.wb_sel);
            }
            $display("DW Stage ---");
            if dwq_rvalid {
                $display("  %h:%h", dwq_rdata.addr, dwq_rdata.instbits);
                $display("  stall     : %d", dw_stall);
                $display("  op1       : %2d:%h", dw_rs1_addr, dw_op1);
                $display("  op2       : %2d:%h", dw_rs2_addr, dw_op2);
                $display("  rs2       : %h", dw_rs2);
            }
            $display("EX Stage ---");
            if exq_rvalid {
                $display("  %h:%h", exq_rdata.addr, exq_rdata.instbits);
                $display("  stall     : %d", !memq_wvalid | !memq_wready);
                $display("  alu_cmd   : %2d", exq_rdata.ctrl.alu_cmd);
                $display("  op1       : %h", exq_rdata.op1);
                $display("  op2       : %h", exq_rdata.op2);
                $display("  alu_out   : %h", ex_alu_out);
                $display("  br_take   : %h", ex_br_taken);
            }
            $display("MEM Stage ---");
            if memq_rvalid {
                mem_is_new = memq_rready;
                $display  ("  %h:%h", memq_rdata.addr, memq_rdata.instbits);
                $display  ("  mem_stall     : %d", mem_memunit_stall);
                $display  ("  mem_cmd      : %d", memq_rdata.ctrl.mem_cmd);
                $display  ("  mem_out      : %h", mem_mem_rdata);
                $display  ("  csr_stall     : %d", mem_csrunit_stall);
                $display  ("  csr_cmd      : %d", memq_rdata.ctrl.csr_cmd);
                if mem_csr_is_trap {
                    $display("  csr hazard: %h", mem_csr_trap_vector);
                } else if mem_is_branch_hazard {
                    $display("  branch hazard: expected:%h actual:%h", mem_next_pc_expected, memq_rdata.pc_next);
                }
            } else {
                mem_is_new = 1;
            }
            $display("WB Stage---");
            if wbq_rvalid {
                $display("  %h:%h", wbq_rdata.addr, wbq_rdata.instbits);
                if wbq_rdata.ctrl.rf_wen & wbq_rdata.wbctx.addr != 0 {
                    $display("  writebacked [%d] <= %h", wbq_rdata.wbctx.addr, wbq_rdata.wbctx.data);
                }
            }
        }
    }

    inst id_unit: inst_decode (
        instbits: idq_rdata.instbits,
        ctrl    : dwq_wdata.ctrl    ,
    );

    inst dw_immdec: imm_decode (
        data : dwq_rdata.instbits,
        imm_i: dw_imm_i          ,
        imm_s: dw_imm_s          ,
        imm_b: _                 ,
        imm_j: dw_imm_j          ,
        imm_u: dw_imm_u          ,
        imm_z: dw_imm_z          ,
    );

    inst regfile_inst: regfile (
        clk                                      ,
        raddr: {dw_rs2_addr, dw_rs1_addr}         ,
        rdata: regfile_rdata                     ,
        wen  : wbq_rvalid & wbq_rdata.ctrl.rf_wen,
        waddr: wbq_rdata.wbctx.addr              ,
        wdata: wbq_rdata.wbctx.data              ,
    );

    inst rs1_forward_unit: reg_forward (
        valid   : dwq_rvalid & dwq_rdata.ctrl.op1_sel == Op1Sel::RS1,
        addr    : dw_rs1_addr                                       ,
        reg_data: regfile_rdata[0]                                  ,

        ex_valid : exq_rvalid & exq_rdata.ctrl.rf_wen,
        ex_can_fw: exq_rdata.wbctx.valid             ,
        ex_addr  : exq_rdata.wbctx.addr              ,
        ex_data  : exq_rdata.wbctx.data              ,

        mem_valid : memq_rvalid & memq_rdata.ctrl.rf_wen,
        mem_can_fw: memq_rdata.wbctx.valid              ,
        mem_addr  : memq_rdata.wbctx.addr               ,
        mem_data  : memq_rdata.wbctx.data               ,

        wb_valid : wbq_rvalid & wbq_rdata.ctrl.rf_wen,
        wb_can_fw: wbq_rdata.wbctx.valid             ,
        wb_addr  : wbq_rdata.wbctx.addr              ,
        wb_data  : wbq_rdata.wbctx.data              ,

        data_hazard: dw_dh_rs1,
        result     : dw_rs1   ,
    );

    inst rs2_forward_unit: reg_forward (
        valid   : dwq_rvalid & dwq_rdata.ctrl.use_rs2,
        addr    : dw_rs2_addr                        ,
        reg_data: regfile_rdata[1]                   ,

        ex_valid : exq_rvalid & exq_rdata.ctrl.rf_wen,
        ex_can_fw: exq_rdata.wbctx.valid             ,
        ex_addr  : exq_rdata.wbctx.addr              ,
        ex_data  : exq_rdata.wbctx.data              ,

        mem_valid : memq_rvalid & memq_rdata.ctrl.rf_wen,
        mem_can_fw: memq_rdata.wbctx.valid              ,
        mem_addr  : memq_rdata.wbctx.addr               ,
        mem_data  : memq_rdata.wbctx.data               ,

        wb_valid : wbq_rvalid & wbq_rdata.ctrl.rf_wen,
        wb_can_fw: wbq_rdata.wbctx.valid             ,
        wb_addr  : wbq_rdata.wbctx.addr              ,
        wb_data  : wbq_rdata.wbctx.data              ,

        data_hazard: dw_dh_rs2,
        result     : dw_rs2   ,
    );

    inst ex_immdec: imm_decode (
        data : exq_rdata.instbits,
        imm_i: _                 ,
        imm_s: _                 ,
        imm_b: ex_imm_b          ,
        imm_j: _                 ,
        imm_u: _                 ,
        imm_z: _                 ,
    );

    inst ex_alu: alu (
        cmd      : exq_rdata.ctrl.alu_cmd  ,
        is_signed: exq_rdata.ctrl.is_signed,
        op1      : exq_rdata.op1           ,
        op2      : exq_rdata.op2           ,
        result   : ex_alu_out              ,
    );

    inst ex_alubr: alubr (
        cmd      : exq_rdata.ctrl.br_cmd   ,
        is_signed: exq_rdata.ctrl.is_signed,
        op1      : exq_rdata.op1           ,
        op2      : exq_rdata.op2           ,
        take     : ex_br_taken             ,
    );

    inst mem_memunit: memunit (
        clk                         ,
        rst                         ,
        dbus_if                     ,
        valid   : memq_rvalid       ,
        is_new  : mem_is_new        ,
        ctrl    : memq_rdata.ctrl   ,
        rs2     : memq_rdata.rs2    ,
        addr    : memq_rdata.alu_out,
        is_stall: mem_memunit_stall ,
        mem_out : mem_mem_rdata     ,
    );

    inst mem_csrunit: csrunit (
        clk                                    ,
        rst                                    ,
        valid      : memq_rvalid               ,
        is_new     : mem_is_new                ,
        pc         : memq_rdata.addr           ,
        cmd        : memq_rdata.ctrl.csr_cmd   ,
        csr_addr   : memq_rdata.instbits[31:20],
        op1_data   : memq_rdata.alu_out        ,
        csr_rdata  : mem_csr_rdata             ,
        is_stall   : mem_csrunit_stall         ,
        is_trap    : mem_csr_is_trap           ,
        trap_vector: mem_csr_trap_vector       ,
    );

    inst fifo_if_id: fifo #(
        Width   : 3       ,
        DataType: idq_type,
    ) (
        clk                                 ,
        rst   : rst & !reset_before_memstage,
        wready: _                           ,
        wvalid: idq_wvalid                  ,
        wdata : idq_wdata                   ,
        rready: idq_rready                  ,
        rvalid: idq_rvalid                  ,
        rdata : idq_rdata                   ,
    );

    assign idq_wready_next = fifo_if_id.wready_next;

    inst fifo_id_dw: fifo #(
        Width   : 0       ,
        DataType: dwq_type,
    ) (
        clk                                 ,
        rst   : rst & !reset_before_memstage,
        wready: dwq_wready                  ,
        wvalid: dwq_wvalid                  ,
        wdata : dwq_wdata                   ,
        rready: dwq_rready                  ,
        rvalid: dwq_rvalid                  ,
        rdata : dwq_rdata                   ,
    );

    inst fifo_dw_ex: fifo #(
        Width   : 0       ,
        DataType: exq_type,
    ) (
        clk                                 ,
        rst   : rst & !reset_before_memstage,
        wready: exq_wready                  ,
        wvalid: exq_wvalid                  ,
        wdata : exq_wdata                   ,
        rready: exq_rready                  ,
        rvalid: exq_rvalid                  ,
        rdata : exq_rdata                   ,
    );

    inst fifo_ex_mem: fifo #(
        Width   : 0        ,
        DataType: memq_type,
    ) (
        clk                                         ,
        rst                                         ,
        wready: memq_wready                         ,
        wvalid: memq_wvalid & !reset_before_memstage,
        wdata : memq_wdata                          ,
        rready: memq_rready                         ,
        rvalid: memq_rvalid                         ,
        rdata : memq_rdata                          ,
    );

    inst fifo_mem_wb: fifo #(
        Width   : 0       ,
        DataType: wbq_type,
    ) (
        clk               ,
        rst               ,
        wready: wbq_wready,
        wvalid: wbq_wvalid,
        wdata : wbq_wdata ,
        rready: wbq_rready,
        rvalid: wbq_rvalid,
        rdata : wbq_rdata ,
    );
}
