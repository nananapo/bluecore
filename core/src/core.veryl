module core (
    clk  : input logic             ,
    rst  : input logic             ,
    ireq : inout meminterface::Req ,
    iresp: inout meminterface::Resp,
    dreq : inout meminterface::Req ,
    dresp: inout meminterface::Resp,

) {

    import conf::*;
    import stage::*;

    // clock count
    var clock_count: u64;

    // stage var
    struct if_idq_type {
        addr   : Addr,
        instbit: Inst,
    }
    var if_idq_wready: logic      ;
    var if_idq_wvalid: logic      ;
    var if_idq_wdata : if_idq_type;
    var if_idq_rready: logic      ;
    var if_idq_rvalid: logic      ;
    var if_idq_rdata : if_idq_type;

    struct stageinfo {
        addr   : Addr    ,
        instbit: Inst    ,
        ctrl   : InstCtrl,
    }

    struct id_exeq_type {
        info: stageinfo,
    }
    var id_exeq_wready: logic       ;
    var id_exeq_wvalid: logic       ;
    var id_exeq_wdata : id_exeq_type;
    var id_exeq_rready: logic       ;
    var id_exeq_rvalid: logic       ;
    var id_exeq_rdata : id_exeq_type;

    struct register_context {
        rs1_addr: logic<5>,
        rs2_addr: logic<5>,
        rd_addr : logic<5>,
    }

    struct exe_memq_type {
        info   : stageinfo       ,
        rs2    : UIntX           ,
        regctx : register_context,
        alu_out: UIntX           ,
    }
    var exe_memq_wready: logic        ;
    var exe_memq_wvalid: logic        ;
    var exe_memq_wdata : exe_memq_type;
    var exe_memq_rready: logic        ;
    var exe_memq_rvalid: logic        ;
    var exe_memq_rdata : exe_memq_type;

    struct mem_wbq_type {
        info   : stageinfo       ,
        regctx : register_context,
        alu_out: UIntX           ,
        mem_out: UIntX           ,
    }
    var mem_wbq_wready: logic       ;
    var mem_wbq_wvalid: logic       ;
    var mem_wbq_wdata : mem_wbq_type;
    var mem_wbq_rready: logic       ;
    var mem_wbq_rvalid: logic       ;
    var mem_wbq_rdata : mem_wbq_type;

    // program counter
    var if_pc          : Addr ;
    var if_is_requested: logic;
    var if_requested_pc: Addr ;

    // fetch
    always_comb {
        ireq.valid = if_idq_wready & (!if_is_requested | iresp.valid);
        ireq.addr  = if iresp.valid {
            if_pc
        } else {
            if_requested_pc
        };
        ireq.wen   = 0;
        ireq.wdata = 'z;
        ireq.wmask = 0;
    }

    // fetched inst
    let if_fetch_inst: Inst = if (if_requested_pc[2] == 0) {
        iresp.rdata[31:0]
    } else {
        iresp.rdata[63:32]
    };

    // if -> id queue
    always_comb {
        if_idq_wvalid        = if_is_requested & iresp.valid;
        if_idq_wdata.addr    = if_requested_pc;
        if_idq_wdata.instbit = if_fetch_inst;
        if_idq_rready        = id_exeq_wready;
    }

    // decode stage
    var id_info: stageinfo;
    always_comb {
        id_info.addr    = if_idq_rdata.addr;
        id_info.instbit = if_idq_rdata.instbit;
        // ctrl is assigned in decoder instance
    }

    // id -> exe queue
    always_comb {
        id_exeq_wvalid     = if_idq_rvalid;
        id_exeq_wdata.info = id_info;
        id_exeq_rready     = !id_exeq_wvalid | exe_memq_wready & exe_memq_wvalid;
    }

    // register
    var regfile: UIntX<32>;

    // exe stage
    let exe_info   : stageinfo = id_exeq_rdata.info;
    var exe_alu_out: UIntX    ;
    var exe_op1    : UIntX    ;
    var exe_op2    : UIntX    ;
    var exe_rs2    : UIntX    ;

    // const value
    let exe_rs1_addr: logic<5> = exe_info.instbit[19:15];
    let exe_rs2_addr: logic<5> = exe_info.instbit[24:20];
    let exe_rd_addr : logic<5> = exe_info.instbit[11:7];
    var exe_imm_i   : UIntX   ;
    var exe_imm_s   : UIntX   ;
    var exe_imm_b   : UIntX   ;
    var exe_imm_j   : UIntX   ;
    var exe_imm_u   : UIntX   ;
    var exe_imm_z   : UIntX   ;

    always_comb {
        exe_op1 = case exe_info.ctrl.op1_sel {
            Op1Sel::RS1: regfile[exe_rs1_addr],
            Op1Sel::PC : exe_info.addr,
            Op1Sel::IMZ: exe_imm_z,
            default    : XLEN_X,
        };
        exe_op2 = case (exe_info.ctrl.op2_sel) {
            Op2Sel::RS2: regfile[exe_rs2_addr],
            Op2Sel::IMI: exe_imm_i,
            Op2Sel::IMS: exe_imm_s,
            Op2Sel::IMJ: exe_imm_j,
            Op2Sel::IMU: exe_imm_u,
            Op2Sel::IMZ: exe_imm_z,
            default    : XLEN_X,
        };
        exe_rs2 = regfile[exe_rs2_addr];
    }

    let exe_dh_rs1: logic = exe_info.ctrl.op1_sel == Op1Sel::RS1 & exe_rs1_addr != 0 & (
    // mem
    exe_memq_rvalid & mem_regctx.rd_addr == exe_rs1_addr |
    // wb
     mem_wbq_rvalid & wb_regctx.rd_addr == exe_rs1_addr);
    let exe_dh_rs2: logic = exe_info.ctrl.use_rs2 & exe_rs2_addr != 0 & (
    // mem
    exe_memq_rvalid & mem_regctx.rd_addr == exe_rs2_addr |
    // wb
     mem_wbq_rvalid & wb_regctx.rd_addr == exe_rs2_addr);
    let exe_stall: logic = exe_dh_rs1 | exe_dh_rs2;

    // exe -> mem queue
    always_comb {
        exe_memq_wvalid                = id_exeq_rvalid & !exe_stall;
        exe_memq_wdata.info            = exe_info;
        exe_memq_wdata.regctx.rs1_addr = if (exe_info.ctrl.op1_sel == Op1Sel::RS1) {
            exe_rs1_addr
        } else {
            0
        };
        exe_memq_wdata.regctx.rs2_addr = if (exe_info.ctrl.use_rs2) {
            exe_rs2_addr
        } else {
            0
        };
        exe_memq_wdata.regctx.rd_addr = if (exe_info.ctrl.rf_wen) {
            exe_rd_addr
        } else {
            0
        };
        exe_memq_wdata.alu_out = exe_alu_out;
        exe_memq_wdata.rs2     = exe_rs2;
    }

    // mem stage
    let mem_valid        : logic            = exe_memq_rvalid;
    var mem_is_new       : logic           ;
    var mem_memunit_stall: logic           ;
    let mem_info         : stageinfo        = exe_memq_rdata.info;
    let mem_regctx       : register_context = exe_memq_rdata.regctx;
    let mem_alu_out      : UIntX            = exe_memq_rdata.alu_out;
    let mem_rs2          : UIntX            = exe_memq_rdata.rs2;
    var mem_mem_rdata    : UIntX           ;

    always_comb {
        exe_memq_rready       = !mem_memunit_stall & mem_wbq_wready;
        mem_wbq_wvalid        = mem_valid & !mem_memunit_stall;
        mem_wbq_wdata.info    = mem_info;
        mem_wbq_wdata.regctx  = mem_regctx;
        mem_wbq_wdata.alu_out = mem_alu_out;
        mem_wbq_wdata.mem_out = mem_mem_rdata;
    }

    // wb stage
    let wb_valid   : logic            = mem_wbq_rvalid;
    let wb_info    : stageinfo        = mem_wbq_rdata.info;
    let wb_regctx  : register_context = mem_wbq_rdata.regctx;
    let _wb_alu_out: UIntX            = mem_wbq_rdata.alu_out;
    let _wb_mem_out: UIntX            = mem_wbq_rdata.mem_out;

    always_comb {
        mem_wbq_rready = 1;
    }

    always_ff (clk, rst) {
        if_reset {
            $display       ("reset!");
            if_pc           = 0;
            if_is_requested = 0;
            if_requested_pc = 0;
            clock_count     = 0;
            regfile[0]      = 0;
            regfile[31:1]   = 'x;
            mem_is_new      = 0;
        } else {
            $display   ("------------------ clock %0d", clock_count);
            clock_count = clock_count + 1;
            $display   ("Fetch Stage ---");
            // fetch stage
            if (if_is_requested) {
                if iresp.valid {
                    $display("  fetched: %h:%h", if_requested_pc, if_fetch_inst);
                    // TODO task? (function emits blocking assignment...)
                    if (ireq.ready & if_idq_wready) {
                        $display       ("  fetch req: %h", if_pc);
                        if_pc           = if_pc + 4;
                        if_is_requested = 1;
                        if_requested_pc = if_pc;
                    } else {
                        if_is_requested = 0;
                    }
                }
            } else {
                if (ireq.ready & if_idq_wready) {
                    $display       ("  fetch req: %h", if_pc);
                    if_pc           = if_pc + 4;
                    if_is_requested = 1;
                    if_requested_pc = if_pc;
                } else {
                    if_is_requested = 0;
                }
            }

            // decode stage
            $display("Decode Stage ---");
            if (if_idq_rvalid) {
                $display("  %h:%h", if_idq_rdata.addr, if_idq_rdata.instbit);
                $display("  is_legal  : %2d", id_info.ctrl.is_legal);
                $display("  alu_cmd   : %2d", id_info.ctrl.alu_cmd);
                $display("  br_cmd    : %2d", id_info.ctrl.br_cmd);
                $display("  is_signed : %2d", id_info.ctrl.is_signed);
                $display("  op1_sel   : %2d", id_info.ctrl.op1_sel);
                $display("  op2_sel   : %2d", id_info.ctrl.op2_sel);
                $display("  use_rs2   : %2d", id_info.ctrl.use_rs2);
                $display("  mem_cmd   : %2d", id_info.ctrl.mem_cmd);
                $display("  mem_size  : %2d", id_info.ctrl.mem_size);
                $display("  csr_cmd   : %2d", id_info.ctrl.csr_cmd);
                $display("  rf_wen    : %2d", id_info.ctrl.rf_wen);
                $display("  wb_sel    : %2d", id_info.ctrl.wb_sel);
            }

            // exe stage
            $display("Exe Stage ---");
            if (id_exeq_rvalid) {
                $display("  %h:%h", exe_info.addr, exe_info.instbit);
                $display("  stall     : %d", exe_stall);
                $display("  alu_cmd   : %2d", exe_info.ctrl.alu_cmd);
                $display("  op1       : %h", exe_op1);
                $display("  op2       : %h", exe_op2);
                $display("  alu_out   : %h", exe_alu_out);
            }
            // mem stage
            $display("Mem Stage ---");
            if (mem_valid) {
                mem_is_new = exe_memq_rready;
                $display  ("  %h:%h", mem_info.addr, mem_info.instbit);
                $display  ("  mu_stall     : %d", mem_memunit_stall);
                $display  ("  mem_cmd   : %d", mem_info.ctrl.mem_cmd);
            } else {
                mem_is_new = 1;
            }

            $display("Wb Stage---");
            if (wb_valid) {
                $display("  %h:%h", wb_info.addr, wb_info.instbit);
            }
        }
    }

    inst decode_unit: decoder (
        instbit: if_idq_rdata.instbit,
        ctrl   : id_info.ctrl        ,
    );

    inst exe_alu: alu (
        cmd      : exe_info.ctrl.alu_cmd  ,
        is_signed: exe_info.ctrl.is_signed,
        op1_data : exe_op1                ,
        op2_data : exe_op2                ,
        result   : exe_alu_out            ,
    );

    inst exe_immdec: imm_decoder (
        data : exe_info.instbit,
        imm_i: exe_imm_i       ,
        imm_s: exe_imm_s       ,
        imm_b: exe_imm_b       ,
        imm_j: exe_imm_j       ,
        imm_u: exe_imm_u       ,
        imm_z: exe_imm_z       ,
    );

    inst mem_memunit: memunit (
        clk                        ,
        rst                        ,
        dreq                       ,
        dresp                      ,
        valid   : mem_valid        ,
        is_new  : mem_is_new       ,
        ctrl    : mem_info.ctrl    ,
        rs2     : mem_rs2          ,
        addr    : mem_alu_out      ,
        is_stall: mem_memunit_stall,
        mem_out : mem_mem_rdata    ,
    );

    inst fifo_fetch_decode: fifo #(
        Width       : 3          ,
        DataType    : if_idq_type,
        FutureWReady: 1          ,
    ) (
        clk                  ,
        rst                  ,
        wready: if_idq_wready,
        wvalid: if_idq_wvalid,
        wdata : if_idq_wdata ,
        rready: if_idq_rready,
        rvalid: if_idq_rvalid,
        rdata : if_idq_rdata ,
    );

    inst fifo_decode_exe: fifo #(
        Width   : 0           ,
        DataType: id_exeq_type,
    ) (
        clk                   ,
        rst                   ,
        wready: id_exeq_wready,
        wvalid: id_exeq_wvalid,
        wdata : id_exeq_wdata ,
        rready: id_exeq_rready,
        rvalid: id_exeq_rvalid,
        rdata : id_exeq_rdata ,
    );

    inst fifo_exe_mem: fifo #(
        Width   : 0            ,
        DataType: exe_memq_type,
    ) (
        clk                    ,
        rst                    ,
        wready: exe_memq_wready,
        wvalid: exe_memq_wvalid,
        wdata : exe_memq_wdata ,
        rready: exe_memq_rready,
        rvalid: exe_memq_rvalid,
        rdata : exe_memq_rdata ,
    );

    inst fifo_mem_wb: fifo #(
        Width   : 0           ,
        DataType: mem_wbq_type,
    ) (
        clk                   ,
        rst                   ,
        wready: mem_wbq_wready,
        wvalid: mem_wbq_wvalid,
        wdata : mem_wbq_wdata ,
        rready: mem_wbq_rready,
        rvalid: mem_wbq_rvalid,
        rdata : mem_wbq_rdata ,
    );
}
