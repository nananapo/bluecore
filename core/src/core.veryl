module core (
    clk    : input   logic           ,
    rst    : input   logic           ,
    ibus_if: modport membus_if::slave,
    dbus_if: modport membus_if::slave,
) {
    import eei::*;
    import corectrl::*;

    struct wb_context {
        valid: logic   ,
        addr : logic<5>,
        data : UIntX   ,
    }

    struct idq_type {
        addr    : Addr,
        instbits: Inst,
    }

    struct dwq_type {
        addr    : Addr    ,
        instbits: Inst    ,
        ctrl    : InstCtrl,
        imm     : UIntX   ,
    }

    struct exq_type {
        addr    : Addr      ,
        instbits: Inst      ,
        ctrl    : InstCtrl  ,
        op1     : UIntX     ,
        op2     : UIntX     ,
        rs2     : UIntX     ,
        imm     : UIntX     ,
        wbctx   : wb_context,
    }

    struct memq_type {
        addr     : Addr      ,
        instbits : Inst      ,
        ctrl     : InstCtrl  ,
        alu_out  : UIntX     ,
        br_taken : logic     ,
        br_target: Addr      ,
        pc_next  : Addr      ,
        pc_inc   : Addr      ,
        op       : UIntX     ,
        imm      : UIntX     ,
        wbctx    : wb_context,
    }

    struct wbq_type {
        addr    : Addr      ,
        instbits: Inst      ,
        ctrl    : InstCtrl  ,
        wbctx   : wb_context,
    }

    var idq_wready_next: logic   ;
    var idq_wvalid     : logic   ;
    var idq_wdata      : idq_type;
    var idq_rready     : logic   ;
    var idq_rvalid     : logic   ;
    var idq_rdata      : idq_type;

    var dwq_wready: logic   ;
    var dwq_wvalid: logic   ;
    var dwq_wdata : dwq_type;
    var dwq_rready: logic   ;
    var dwq_rvalid: logic   ;
    var dwq_rdata : dwq_type;

    var exq_wready: logic   ;
    var exq_wvalid: logic   ;
    var exq_wdata : exq_type;
    var exq_rready: logic   ;
    var exq_rvalid: logic   ;
    var exq_rdata : exq_type;

    var memq_wready: logic    ;
    var memq_wvalid: logic    ;
    var memq_wdata : memq_type;
    var memq_rready: logic    ;
    var memq_rvalid: logic    ;
    var memq_rdata : memq_type;

    var wbq_wready: logic   ;
    var wbq_wvalid: logic   ;
    var wbq_wdata : wbq_type;
    var wbq_rready: logic   ;
    var wbq_rvalid: logic   ;
    var wbq_rdata : wbq_type;

    // IF stage
    var if_pc          : Addr ;
    var if_is_requested: logic;
    var if_requested_pc: Addr ;

    always_comb {
        ibus_if.valid = idq_wready_next & (!if_is_requested | ibus_if.resp_valid);
        ibus_if.addr  = if_pc;
        ibus_if.wen   = 0;
        ibus_if.wdata = 'x;
        ibus_if.wmask = 0;
    }

    let if_inst_fetched: Inst = if if_requested_pc[2] == 0 {
        ibus_if.resp_rdata[31:0]
    } else {
        ibus_if.resp_rdata[63:32]
    };

    always_comb {
        // IF stage -> ID stage
        idq_wvalid         = if_is_requested & ibus_if.resp_valid;
        idq_wdata.addr     = if_requested_pc;
        idq_wdata.instbits = if_inst_fetched;
        idq_rready         = dwq_wready;
        // ID stage -> DW stage
        dwq_wvalid         = idq_rvalid;
        dwq_wdata.addr     = idq_rdata.addr;
        dwq_wdata.instbits = idq_rdata.instbits;
        dwq_rready         = exq_wready & exq_wvalid;
    }

    // DW stage
    let dw_rs1_addr: logic<5> = dwq_rdata.instbits[19:15];
    let dw_rs2_addr: logic<5> = dwq_rdata.instbits[24:20];
    let dw_rd_addr : logic<5> = dwq_rdata.instbits[11:7];

    var registers: UIntX<32>;

    var dw_op1: UIntX;
    var dw_op2: UIntX;
    var dw_rs1: UIntX;
    var dw_rs2: UIntX;

    var dw_dh_rs1: logic;
    var dw_dh_rs2: logic;

    let dw_stall: logic = dw_dh_rs1 | dw_dh_rs2;

    always_comb {
        case dwq_rdata.ctrl.insttype {
            InstType::R, InstType::B: {
                                          dw_op1 = dw_rs1;
                                          dw_op2 = dw_rs2;
                                      }
            InstType::I, InstType::S: {
                                          dw_op1 = dw_rs1;
                                          dw_op2 = dwq_rdata.imm;
                                      }
            InstType::U, InstType::J: {
                                          dw_op1 = dwq_rdata.addr;
                                          dw_op2 = dwq_rdata.imm;
                                      }
            default: {
                         dw_op1 = 'x;
                         dw_op2 = 'x;
                     }
        }
    }

    // DW stage -> EX stage
    always_comb {
        exq_wvalid            = dwq_rvalid & !dw_stall;
        exq_wdata.addr        = dwq_rdata.addr;
        exq_wdata.instbits    = dwq_rdata.instbits;
        exq_wdata.ctrl        = dwq_rdata.ctrl;
        exq_wdata.op1         = dw_op1;
        exq_wdata.op2         = dw_op2;
        exq_wdata.rs2         = dw_rs2;
        exq_wdata.imm         = dwq_rdata.imm;
        exq_wdata.wbctx.valid = inst_is_lui(dwq_rdata.ctrl) | inst_is_branch(dwq_rdata.ctrl) | inst_is_jump(dwq_rdata.ctrl);
        exq_wdata.wbctx.addr  = dw_rd_addr;
        exq_wdata.wbctx.data  = if inst_is_lui(dwq_rdata.ctrl) {
            dwq_rdata.imm
        } else {
            dwq_rdata.addr + 4
        };
        exq_rready = memq_wready & memq_wvalid;
    }

    // EX stage
    var ex_alu_out : UIntX;
    var ex_br_taken: logic;

    let ex_stall: logic = !dwq_rvalid; // wait dw is valid

    // EX stage -> MEM stage
    always_comb {
        memq_wvalid          = exq_rvalid & !ex_stall;
        memq_wdata.addr      = exq_rdata.addr;
        memq_wdata.instbits  = exq_rdata.instbits;
        memq_wdata.ctrl      = exq_rdata.ctrl;
        memq_wdata.alu_out   = ex_alu_out;
        memq_wdata.br_taken  = inst_is_branch(exq_rdata.ctrl) & ex_br_taken | exq_rdata.ctrl.is_jump;
        memq_wdata.br_target = if inst_is_branch(exq_rdata.ctrl) {
            exq_rdata.addr + exq_rdata.imm
        } else {
            ex_alu_out
        } & ~1;
        memq_wdata.pc_next = dwq_rdata.addr;
        memq_wdata.pc_inc  = exq_rdata.addr + 4;
        memq_wdata.op      = if exq_rdata.ctrl.is_system {
            exq_rdata.op1
        } else {
            exq_rdata.rs2
        };
        memq_wdata.imm         = exq_rdata.imm;
        memq_wdata.wbctx.valid = exq_rdata.wbctx.valid | !(inst_is_memory_op(exq_rdata.ctrl) | inst_is_csr_op(exq_rdata.ctrl));
        memq_wdata.wbctx.addr  = exq_rdata.wbctx.addr;
        memq_wdata.wbctx.data  = if exq_rdata.wbctx.valid {
            exq_rdata.wbctx.data
        } else {
            ex_alu_out
        };
        memq_rready = wbq_wvalid & wbq_wready;
    }

    // mem stage
    var mem_is_new       : logic;
    var mem_memunit_stall: logic;
    var mem_mem_rdata    : UIntX;

    var mem_next_pc_expected: Addr ;
    var mem_is_branch_hazard: logic;

    var mem_csr_rdata      : UIntX;
    var mem_csrunit_stall  : logic;
    var mem_csr_is_trap    : logic;
    var mem_csr_trap_vector: Addr ;

    assign mem_next_pc_expected = if !memq_rdata.br_taken {
        memq_rdata.pc_inc
    } else {
        memq_rdata.br_target
    };

    assign mem_is_branch_hazard = memq_rvalid & mem_next_pc_expected != memq_rdata.pc_next;

    always_comb {
        wbq_wvalid            = memq_rvalid & !mem_memunit_stall & !mem_csrunit_stall;
        wbq_wdata.addr        = memq_rdata.addr;
        wbq_wdata.instbits    = memq_rdata.instbits;
        wbq_wdata.ctrl        = memq_rdata.ctrl;
        wbq_wdata.wbctx.valid = 1;
        wbq_wdata.wbctx.addr  = memq_rdata.wbctx.addr;
        wbq_wdata.wbctx.data  = if memq_rdata.wbctx.valid {
            memq_rdata.wbctx.data
        } else if inst_is_memory_op(memq_rdata.ctrl) {
            mem_mem_rdata
        } else {
            mem_csr_rdata
        };
        wbq_rready = 1;
    }

    let reset_before_memstage: logic = mem_is_branch_hazard | mem_csr_is_trap;

    var clock_count: i64;

    always_ff (clk, rst) {
        if_reset {
            $display       ("reset!");
            if_pc           = 0;
            if_is_requested = 0;
            if_requested_pc = 0;
            mem_is_new      = 0;
            clock_count     = 0;
            registers       = 'x;
        } else {
            clock_count = clock_count + 1;
            $display   ("------------------ clock %0d", clock_count);
            $display   ("IF Stage ---");
            if reset_before_memstage {
                if_is_requested = 0;
                if_pc           = if mem_csr_is_trap {
                    mem_csr_trap_vector
                } else if mem_is_branch_hazard {
                    mem_next_pc_expected
                } else {
                    0
                };
            } else {
                if if_is_requested & ibus_if.resp_valid {
                    $display("  fetched: %h:%h", if_requested_pc, if_inst_fetched);
                }
                if ibus_if.ready & ibus_if.valid {
                    if_pc           = if_pc + 4;
                    if_is_requested = 1;
                    if_requested_pc = if_pc;
                    $display       ("  fetch req: %h", ibus_if.addr);
                } else {
                    if_is_requested = 0;
                }
            }
            $display("ID Stage ---");
            if idq_rvalid {
                $display("  %h:%h", idq_rdata.addr, idq_rdata.instbits);
                $display("  is_legal  : %2d", dwq_wdata.ctrl.is_legal);
                $display("  insttype  : %2d", dwq_wdata.ctrl.insttype);
                $display("  rf_wen    : %2d", dwq_wdata.ctrl.rf_wen);
                $display("  is_lui    : %2d", dwq_wdata.ctrl.is_lui);
                $display("  is_aluop  : %2d", dwq_wdata.ctrl.is_aluop);
                $display("  is_jump   : %2d", dwq_wdata.ctrl.is_jump);
                $display("  is_load   : %2d", dwq_wdata.ctrl.is_load);
                $display("  is_system : %2d", dwq_wdata.ctrl.is_system);
                $display("  is_fence  : %2d", dwq_wdata.ctrl.is_fence);
                $display("  funct3    : %b", dwq_wdata.ctrl.funct3);
                $display("  funct7    : %b", dwq_wdata.ctrl.funct7);
            }
            $display("DW Stage ---");
            if dwq_rvalid {
                $display("  %h:%h", dwq_rdata.addr, dwq_rdata.instbits);
                $display("  stall     : %d", dw_stall);
                $display("  op1       : %2d:%h", dw_rs1_addr, dw_op1);
                $display("  op2       : %2d:%h", dw_rs2_addr, dw_op2);
                $display("  rs2       : %h", dw_rs2);
            }
            $display("EX Stage ---");
            if exq_rvalid {
                $display("  %h:%h", exq_rdata.addr, exq_rdata.instbits);
                $display("  stall     : %d", !memq_wvalid | !memq_wready);
                $display("  funct3    : %2d", exq_rdata.ctrl.funct3);
                $display("  funct7    : %2d", exq_rdata.ctrl.funct7);
                $display("  is_aluop  : %2d", exq_rdata.ctrl.is_aluop);
                $display("  op1       : %h", exq_rdata.op1);
                $display("  op2       : %h", exq_rdata.op2);
                $display("  alu_out   : %h", ex_alu_out);
                $display("  br_take   : %h", ex_br_taken);
            }
            $display("MEM Stage ---");
            if memq_rvalid {
                mem_is_new = memq_rready;
                $display  ("  %h:%h", memq_rdata.addr, memq_rdata.instbits);
                $display  ("  is_mem_op    : %d", inst_is_memory_op(memq_rdata.ctrl));
                $display  ("  is_csr_op    : %d", inst_is_csr_op(memq_rdata.ctrl));
                $display  ("  funct3       : %2d", memq_rdata.ctrl.funct3);
                $display  ("  mem_stall    : %d", mem_memunit_stall);
                $display  ("  csr_stall    : %d", mem_csrunit_stall);
                $display  ("  mem_out      : %h", mem_mem_rdata);
                $display  ("  csr_out      : %h", mem_csr_rdata);
                if mem_csr_is_trap {
                    $display("  csr hazard: %h", mem_csr_trap_vector);
                } else if mem_is_branch_hazard {
                    $display("  branch hazard: expected:%h actual:%h", mem_next_pc_expected, memq_rdata.pc_next);
                }
            } else {
                mem_is_new = 1;
            }
            $display("WB Stage---");
            if wbq_rvalid {
                $display("  %h:%h", wbq_rdata.addr, wbq_rdata.instbits);
                if wbq_rdata.ctrl.rf_wen {
                    registers[wbq_rdata.wbctx.addr] = wbq_rdata.wbctx.data;
                    $display                       ("  writebacked [%d] <= %h", wbq_rdata.wbctx.addr, wbq_rdata.wbctx.data);
                }
            }
        }
    }

    inst id_unit: inst_decode (
        bits: idq_rdata.instbits,
        ctrl: dwq_wdata.ctrl    ,
        imm : dwq_wdata.imm     ,
    );

    inst rs1_forward_unit: reg_forward (
        valid   : dwq_rvalid & inst_use_rs1(dwq_rdata.ctrl),
        addr    : dw_rs1_addr                              ,
        reg_data: registers[dw_rs1_addr]                   ,

        ex_valid : exq_rvalid & exq_rdata.ctrl.rf_wen,
        ex_can_fw: exq_rdata.wbctx.valid             ,
        ex_addr  : exq_rdata.wbctx.addr              ,
        ex_data  : exq_rdata.wbctx.data              ,

        mem_valid : memq_rvalid & memq_rdata.ctrl.rf_wen,
        mem_can_fw: memq_rdata.wbctx.valid              ,
        mem_addr  : memq_rdata.wbctx.addr               ,
        mem_data  : memq_rdata.wbctx.data               ,

        wb_valid : wbq_rvalid & wbq_rdata.ctrl.rf_wen,
        wb_can_fw: wbq_rdata.wbctx.valid             ,
        wb_addr  : wbq_rdata.wbctx.addr              ,
        wb_data  : wbq_rdata.wbctx.data              ,

        data_hazard: dw_dh_rs1,
        result     : dw_rs1   ,
    );

    inst rs2_forward_unit: reg_forward (
        valid   : dwq_rvalid & inst_use_rs2(dwq_rdata.ctrl),
        addr    : dw_rs2_addr                              ,
        reg_data: registers[dw_rs2_addr]                   ,

        ex_valid : exq_rvalid & exq_rdata.ctrl.rf_wen,
        ex_can_fw: exq_rdata.wbctx.valid             ,
        ex_addr  : exq_rdata.wbctx.addr              ,
        ex_data  : exq_rdata.wbctx.data              ,

        mem_valid : memq_rvalid & memq_rdata.ctrl.rf_wen,
        mem_can_fw: memq_rdata.wbctx.valid              ,
        mem_addr  : memq_rdata.wbctx.addr               ,
        mem_data  : memq_rdata.wbctx.data               ,

        wb_valid : wbq_rvalid & wbq_rdata.ctrl.rf_wen,
        wb_can_fw: wbq_rdata.wbctx.valid             ,
        wb_addr  : wbq_rdata.wbctx.addr              ,
        wb_data  : wbq_rdata.wbctx.data              ,

        data_hazard: dw_dh_rs2,
        result     : dw_rs2   ,
    );

    inst ex_alu: alu (
        ctrl  : exq_rdata.ctrl,
        op1   : exq_rdata.op1 ,
        op2   : exq_rdata.op2 ,
        result: ex_alu_out    ,
    );

    inst ex_alubr: alubr (
        funct3: exq_rdata.ctrl.funct3,
        op1   : exq_rdata.op1        ,
        op2   : exq_rdata.op2        ,
        take  : ex_br_taken          ,
    );

    inst mem_memunit: memunit (
        clk                         ,
        rst                         ,
        dbus_if                     ,
        valid   : memq_rvalid       ,
        is_new  : mem_is_new        ,
        ctrl    : memq_rdata.ctrl   ,
        rs2     : memq_rdata.op     ,
        addr    : memq_rdata.alu_out,
        is_stall: mem_memunit_stall ,
        mem_out : mem_mem_rdata     ,
    );

    inst mem_csrunit: csrunit (
        clk                               ,
        rst                               ,
        valid      : memq_rvalid          ,
        is_new     : mem_is_new           ,
        csr_rdata  : mem_csr_rdata        ,
        is_stall   : mem_csrunit_stall    ,
        is_trap    : mem_csr_is_trap      ,
        trap_vector: mem_csr_trap_vector  ,
        pc         : memq_rdata.addr      ,
        ctrl       : memq_rdata.ctrl      ,
        rd_addr    : memq_rdata.wbctx.addr,
        csr_addr   : memq_rdata.imm[16:5] ,
        rs1        : if memq_rdata.ctrl.funct3[2] == 0 {
            memq_rdata.op
        } else {
            {memq_rdata.imm[4] repeat XLEN - 5, memq_rdata.imm[4:0]}
        },
    );

    inst fifo_if_id: fifo #(
        Width   : 3       ,
        DataType: idq_type,
    ) (
        clk                                 ,
        rst   : rst & !reset_before_memstage,
        wready: _                           ,
        wvalid: idq_wvalid                  ,
        wdata : idq_wdata                   ,
        rready: idq_rready                  ,
        rvalid: idq_rvalid                  ,
        rdata : idq_rdata                   ,
    );

    assign idq_wready_next = fifo_if_id.wready_next;

    inst fifo_id_dw: fifo #(
        Width   : 0       ,
        DataType: dwq_type,
    ) (
        clk                                 ,
        rst   : rst & !reset_before_memstage,
        wready: dwq_wready                  ,
        wvalid: dwq_wvalid                  ,
        wdata : dwq_wdata                   ,
        rready: dwq_rready                  ,
        rvalid: dwq_rvalid                  ,
        rdata : dwq_rdata                   ,
    );

    inst fifo_dw_ex: fifo #(
        Width   : 0       ,
        DataType: exq_type,
    ) (
        clk                                 ,
        rst   : rst & !reset_before_memstage,
        wready: exq_wready                  ,
        wvalid: exq_wvalid                  ,
        wdata : exq_wdata                   ,
        rready: exq_rready                  ,
        rvalid: exq_rvalid                  ,
        rdata : exq_rdata                   ,
    );

    inst fifo_ex_mem: fifo #(
        Width   : 0        ,
        DataType: memq_type,
    ) (
        clk                                         ,
        rst                                         ,
        wready: memq_wready                         ,
        wvalid: memq_wvalid & !reset_before_memstage,
        wdata : memq_wdata                          ,
        rready: memq_rready                         ,
        rvalid: memq_rvalid                         ,
        rdata : memq_rdata                          ,
    );

    inst fifo_mem_wb: fifo #(
        Width   : 0       ,
        DataType: wbq_type,
    ) (
        clk               ,
        rst               ,
        wready: wbq_wready,
        wvalid: wbq_wvalid,
        wdata : wbq_wdata ,
        rready: wbq_rready,
        rvalid: wbq_rvalid,
        rdata : wbq_rdata ,
    );
}
