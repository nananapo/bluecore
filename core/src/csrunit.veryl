import eei::*;
import corectrl::*;

// #@@range_begin(port)
module csrunit (
    ...
    rdata      : output UIntX       ,
    raise_trap : output logic       ,
    trap_vector: output Addr        ,
    @<b>|led        : output UIntX       ,|
) {
// #@@range_end(port)

    // CSRのアドレス
// #@@range_begin(addr)
    enum CsrAddr: logic<12> {
        MTVEC = 12'h305,
        MEPC = 12'h341,
        MCAUSE = 12'h342,
        @<b>|LED = 12'h800,|
    }
// #@@range_end(addr)

    enum CsrCause: UIntX {
        ENVIRONMENT_CALL_FROM_M_MODE = 11,
    }

    // wmasks
    const MTVEC_WMASK : UIntX = 'hffff_ffff_ffff_fffc;
    const MEPC_WMASK  : UIntX = 'hffff_ffff_ffff_fffc;
    const MCAUSE_WMASK: UIntX = 'hffff_ffff_ffff_ffff;
// #@@range_begin(wmask)
    const LED_WMASK   : UIntX = 'hffff_ffff_ffff_ffff;
// #@@range_end(wmask)

    // CSRR(W|S|C)[I]命令かどうか
    let is_wsc: logic = ctrl.is_csr && ctrl.funct3[1:0] != 0;
    // ECALL命令かどうか
    let is_ecall: logic = ctrl.is_csr && csr_addr == 0 && rs1[4:0] == 0 && ctrl.funct3 == 0 && rd_addr == 0;
    // MRET命令かどうか
    let is_mret: logic = ctrl.is_csr && csr_addr == 12'b0011000_00010 && rs1[4:0] == 0 && ctrl.funct3 == 0 && rd_addr == 0;

    // CSR
    var mtvec : UIntX;
    var mepc  : UIntX;
    var mcause: UIntX;

    // Exception
    let raise_expt: logic = valid && is_ecall;
    let expt_cause: UIntX = CsrCause::ENVIRONMENT_CALL_FROM_M_MODE;

    // Trap
    assign raise_trap  = raise_expt || (valid && is_mret);
    let trap_cause : UIntX = expt_cause;
    assign trap_vector = if raise_expt {
        mtvec
    } else {
        mepc
    };

    var wmask: UIntX; // write mask
    var wdata: UIntX; // write data

    always_comb {
    // #@@range_begin(rdata_wmask)
    // read
    rdata = case csr_addr {
        CsrAddr::MTVEC : mtvec,
        CsrAddr::MEPC  : mepc,
        CsrAddr::MCAUSE: mcause,
        @<b>|CsrAddr::LED   : led,|
        default        : 'x,
    };
    // write
    wmask = case csr_addr {
        CsrAddr::MTVEC : MTVEC_WMASK,
        CsrAddr::MEPC  : MEPC_WMASK,
        CsrAddr::MCAUSE: MCAUSE_WMASK,
        @<b>|CsrAddr::LED   : LED_WMASK,|
        default        : 0,
    };
    // #@@range_end(rdata_wmask)
        wdata = case ctrl.funct3[1:0] {
            2'b01  : rs1,
            2'b10  : rdata | rs1,
            2'b11  : rdata & ~rs1,
            default: 'x,
        } & wmask;
    }

    always_ff {
// #@@range_begin(reset)
    if_reset {
        mtvec  = 0;
        mepc   = 0;
        mcause = 0;
        @<b>|led    = 0;|
    } else {
// #@@range_end(reset)
            if valid {
                if raise_trap {
                    mepc   = pc;
                    mcause = trap_cause;
                } else {
                    if is_wsc {
// #@@range_begin(write)
    case csr_addr {
        CsrAddr::MTVEC : mtvec  = wdata;
        CsrAddr::MEPC  : mepc   = wdata;
        CsrAddr::MCAUSE: mcause = wdata;
        @<b>|CsrAddr::LED   : led    = wdata;|
        default        : {}
    }
// #@@range_end(write)
                    }
                }
            }
        }
    }
}
