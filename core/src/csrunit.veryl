import eei::*;
import corectrl::*;

module csrunit (
    clk        : input  clock            ,
    rst        : input  reset            ,
    valid      : input  logic            ,
    pc         : input  Addr             ,
    inst_bits  : input  Inst             ,
    ctrl       : input  InstCtrl         ,
    expt_info  : input  ExceptionInfo    ,
    rd_addr    : input  logic        <5> ,
    csr_addr   : input  logic        <12>,
    rs1_addr   : input  logic        <5> ,
    rs1_data   : input  UIntX            ,
    rdata      : output UIntX            ,
    raise_trap : output logic            ,
    trap_vector: output Addr             ,
    trap_return: output logic            ,
    minstret   : input  UInt64           ,
    led        : output UIntX            ,
) {

    // wmasks
    const MSTATUS_WMASK : UIntX = 'h0000_0000_0000_0000 as UIntX;
    const MTVEC_WMASK   : UIntX = 'hffff_ffff_ffff_fffc;
    const MSCRATCH_WMASK: UIntX = 'hffff_ffff_ffff_ffff;
    const MEPC_WMASK    : UIntX = 'hffff_ffff_ffff_fffe;
    const MCAUSE_WMASK  : UIntX = 'hffff_ffff_ffff_ffff;
    const MTVAL_WMASK   : UIntX = 'hffff_ffff_ffff_ffff;
    const LED_WMASK     : UIntX = 'hffff_ffff_ffff_ffff;

    var mode: PrivMode;

    // CSRR(W|S|C)[I]命令かどうか
    let is_wsc: logic = ctrl.is_csr && ctrl.funct3[1:0] != 0;
    // MRET命令かどうか
    let is_mret: logic = inst_bits == 32'h30200073;

    // Check CSR access
    let will_not_write_csr     : logic = (ctrl.funct3[1:0] == 2 || ctrl.funct3[1:0] == 3) && rs1_addr == 0; // set/clear with source = 0
    let expt_write_readonly_csr: logic = is_wsc && !will_not_write_csr && csr_addr[11:10] == 2'b11; // attempt to write read-only CSR

    // CSR
    let misa    : UIntX  = {2'd2, 1'b0 repeat XLEN - 28, 26'b00000000000001000100000101}; // M, I, C, A
    let mhartid : UIntX  = 0;
    var mstatus : UIntX ;
    var mtvec   : UIntX ;
    var mcycle  : UInt64;
    var mscratch: UIntX ;
    var mepc    : UIntX ;
    var mcause  : UIntX ;
    var mtval   : UIntX ;

    // Exception
    let raise_expt: logic = valid && (expt_info.valid || expt_write_readonly_csr);
    let expt_cause: UIntX = switch {
        expt_info.valid        : expt_info.cause,
        expt_write_readonly_csr: CsrCause::ILLEGAL_INSTRUCTION,
        default                : 0,
    };
    let expt_value: UIntX = switch {
        expt_info.valid                            : expt_info.value,
        expt_cause == CsrCause::ILLEGAL_INSTRUCTION: {1'b0 repeat XLEN - $bits(Inst), inst_bits},
        default                                    : 0
    };

    // Trap Return
    assign trap_return = valid && is_mret && !raise_expt;

    // Trap
    assign raise_trap  = raise_expt || trap_return;
    let trap_cause : UIntX = expt_cause;
    assign trap_vector = if raise_expt ? mtvec : mepc;

    var wmask: UIntX; // write mask
    var wdata: UIntX; // write data

    always_comb {
        // read
        rdata = case csr_addr {
            CsrAddr::MISA    : misa,
            CsrAddr::MIMPID  : MACHINE_IMPLEMENTATION_ID,
            CsrAddr::MHARTID : mhartid,
            CsrAddr::MSTATUS : mstatus,
            CsrAddr::MTVEC   : mtvec,
            CsrAddr::MCYCLE  : mcycle,
            CsrAddr::MINSTRET: minstret,
            CsrAddr::MSCRATCH: mscratch,
            CsrAddr::MEPC    : mepc,
            CsrAddr::MCAUSE  : mcause,
            CsrAddr::MTVAL   : mtval,
            CsrAddr::LED     : led,
            default          : 'x,
        };
        // write
        wmask = case csr_addr {
            CsrAddr::MSTATUS : MSTATUS_WMASK,
            CsrAddr::MTVEC   : MTVEC_WMASK,
            CsrAddr::MSCRATCH: MSCRATCH_WMASK,
            CsrAddr::MEPC    : MEPC_WMASK,
            CsrAddr::MCAUSE  : MCAUSE_WMASK,
            CsrAddr::MTVAL   : MTVAL_WMASK,
            CsrAddr::LED     : LED_WMASK,
            default          : 0,
        };
        let wsource: UIntX = if ctrl.funct3[2] ? {1'b0 repeat XLEN - 5, rs1_addr} : rs1_data;
        wdata   = case ctrl.funct3[1:0] {
            2'b01  : wsource,
            2'b10  : rdata | wsource,
            2'b11  : rdata & ~wsource,
            default: 'x,
        } & wmask | (rdata & ~wmask);
    }

    always_ff {
        if_reset {
            mode     = PrivMode::M;
            mstatus  = 0;
            mtvec    = 0;
            mscratch = 0;
            mcycle   = 0;
            mepc     = 0;
            mcause   = 0;
            mtval    = 0;
            led      = 0;
        } else {
            mcycle += 1;
            if valid {
                if raise_trap {
                    if raise_expt {
                        mepc   = pc;
                        mcause = trap_cause;
                        mtval  = expt_value;
                    }
                } else {
                    if is_wsc {
                        case csr_addr {
                            CsrAddr::MSTATUS : mstatus  = wdata;
                            CsrAddr::MTVEC   : mtvec    = wdata;
                            CsrAddr::MSCRATCH: mscratch = wdata;
                            CsrAddr::MEPC    : mepc     = wdata;
                            CsrAddr::MCAUSE  : mcause   = wdata;
                            CsrAddr::MTVAL   : mtval    = wdata;
                            CsrAddr::LED     : led      = wdata;
                            default          : {}
                        }
                    }
                }
            }
        }
    }
}
