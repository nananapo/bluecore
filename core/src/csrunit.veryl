import eei::*;
import corectrl::*;

module csrunit (
    clk        : input  clock            ,
    rst        : input  reset            ,
    valid      : input  logic            ,
    pc         : input  Addr             ,
    ctrl       : input  InstCtrl         ,
    expt_info  : input  ExceptionInfo    ,
    rd_addr    : input  logic        <5> ,
    csr_addr   : input  logic        <12>,
    rs1        : input  UIntX            ,
    rdata      : output UIntX            ,
    raise_trap : output logic            ,
    trap_vector: output Addr             ,
    led        : output UIntX            ,
) {

    // wmasks
    const MTVEC_WMASK : UIntX = 'hffff_ffff_ffff_fffc;
    const MEPC_WMASK  : UIntX = 'hffff_ffff_ffff_fffc;
    const MCAUSE_WMASK: UIntX = 'hffff_ffff_ffff_ffff;
    const MTVAL_WMASK : UIntX = 'hffff_ffff_ffff_ffff;
    const LED_WMASK   : UIntX = 'hffff_ffff_ffff_ffff;

    // CSRR(W|S|C)[I]命令かどうか
    let is_wsc: logic = ctrl.is_csr && ctrl.funct3[1:0] != 0;
    // MRET命令かどうか
    let is_mret: logic = ctrl.is_csr && csr_addr == 12'b0011000_00010 && rs1[4:0] == 0 && ctrl.funct3 == 0 && rd_addr == 0;

    // CSR
    var mtvec : UIntX;
    var mepc  : UIntX;
    var mcause: UIntX;
    var mtval : UIntX;

    // Exception
    let raise_expt : logic = valid && expt_info.valid;
    let expt_cause : UIntX = expt_info.cause;
    let expt_value : UIntX = expt_info.value;

    // Trap
    assign raise_trap  = raise_expt || (valid && is_mret);
    let trap_cause : UIntX = expt_cause;
    assign trap_vector = if raise_expt ? mtvec : mepc;

    var wmask: UIntX; // write mask
    var wdata: UIntX; // write data

    always_comb {
        // read
        rdata = case csr_addr {
            CsrAddr::MTVEC : mtvec,
            CsrAddr::MEPC  : mepc,
            CsrAddr::MCAUSE: mcause,
            CsrAddr::MTVAL : mtval,
            CsrAddr::LED   : led,
            default        : 'x,
        };
        // write
        wmask = case csr_addr {
            CsrAddr::MTVEC : MTVEC_WMASK,
            CsrAddr::MEPC  : MEPC_WMASK,
            CsrAddr::MCAUSE: MCAUSE_WMASK,
            CsrAddr::MTVAL : MTVAL_WMASK,
            CsrAddr::LED   : LED_WMASK,
            default        : 0,
        };
        wdata = case ctrl.funct3[1:0] {
            2'b01  : rs1,
            2'b10  : rdata | rs1,
            2'b11  : rdata & ~rs1,
            default: 'x,
        } & wmask | (rdata & ~wmask);
    }

    always_ff {
        if_reset {
            mtvec  = 0;
            mepc   = 0;
            mcause = 0;
            mtval  = 0;
            led    = 0;
        } else {
            if valid {
                if raise_trap {
                    if raise_expt {
                        mepc   = pc;
                        mcause = trap_cause;
                        mtval  = expt_value;
                    }
                } else {
                    if is_wsc {
                        case csr_addr {
                            CsrAddr::MTVEC : mtvec  = wdata;
                            CsrAddr::MEPC  : mepc   = wdata;
                            CsrAddr::MCAUSE: mcause = wdata;
                            CsrAddr::MTVAL : mtval  = wdata;
                            CsrAddr::LED   : led    = wdata;
                            default        : {}
                        }
                    }
                }
            }
        }
    }
}
